<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 知识库流程可视化</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas { 
            width: 100%; 
            height: 100%;
            position: fixed;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
            font-size: 16px;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
        }
        .step-btn {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
        }
        .step-btn:hover {
            background: #2980b9;
        }
        .step-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .label {
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 5px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            font-size: 14px;
            pointer-events: none;
        }
        .chunk-label {
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 5px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            max-width: 150px;
            word-wrap: break-word;
        }
        #copyright {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-family: Arial, sans-serif;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #copyright a {
            pointer-events: auto;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 300px;
        }
        
        .chunk-point {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .chunk-point:hover {
            transform: scale(1.2);
        }
        
        .chunk-point.selected {
            box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.8);
        }
        
        #similarity-panel {
            position: absolute;
            top: 85px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
            width: 300px;
        }
        
        .similarity-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        
        .similarity-value {
            color: #ffcc00;
            font-weight: bold;
            font-size: 18px;
        }
        
        #rag-controls {
            position: absolute;
            top: 85px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
            width: 300px;
        }
        
        .parameter-section {
            margin-bottom: 15px;
        }
        
        .parameter-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .slider {
            flex-grow: 1;
            margin: 0 10px;
        }
        
        .param-description {
            font-size: 12px;
            margin-top: 5px;
            line-height: 1.3;
            color: #aaa;
        }
        
        #query-input-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
            width: 300px;
        }
        
        #query-text-input {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 3px;
            color: white;
            font-size: 14px;
        }
        
        #query-text-input:focus {
            outline: none;
            border-color: #3498db;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <div id="info">
        <h2>AI 知识库流程可视化</h2>
        <p id="step-description">欢迎来到AI知识库流程可视化！点击"开始"按钮开始演示。</p>
    </div>
    <div id="controls">
        <button class="step-btn" id="start-btn">开始</button>
        <button class="step-btn" id="prev-btn" disabled>上一步</button>
        <button class="step-btn" id="next-btn" disabled>下一步</button>
        <button class="step-btn" id="reset-btn">重置</button>
    </div>
    
    <div id="similarity-panel">
        <h3>相似度信息</h3>
        <div id="similarity-content"></div>
    </div>
    
    <div id="query-input-panel">
        <h3>查询输入</h3>
        <p style="font-size: 12px; color: #aaa; margin-top: 5px;">输入查询文本，系统将转换为embedding向量</p>
        <input type="text" id="query-text-input" placeholder="输入查询文本..." value="什么是注意力机制？">
        <button class="step-btn" id="convert-query-btn" style="margin-top: 10px; width: 100%;">转换为Embedding</button>
    </div>
    
    <div id="rag-controls">
        <h3>RAG 参数控制</h3>
        
        <div class="parameter-section">
            <h4>Top-K (选择数量)</h4>
            <div class="slider-container">
                <span>1</span>
                <input type="range" min="1" max="12" step="1" value="3" class="slider" id="topk-slider">
                <span>12</span>
            </div>
            <div id="topk-value">当前值: 3</div>
            <p class="param-description">选择相似度最高的K个chunk用于RAG生成</p>
        </div>
        
        <div class="parameter-section">
            <h4>相似度阈值</h4>
            <div class="slider-container">
                <span>0</span>
                <input type="range" min="0" max="1" step="0.05" value="0.5" class="slider" id="threshold-slider">
                <span>1</span>
            </div>
            <div id="threshold-value">当前值: 0.50</div>
            <p class="param-description">只选择相似度高于此阈值的chunk（可选）</p>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <!-- Add copyright information at the end of the body -->
    <div id="copyright">
        <span>© Senparc</span>
        <span> | <a href="https://github.com/Senparc/Senparc.AI/tree/main/documents/AI-Knowledge/Transformer" target="_blank" style="color: rgba(255, 255, 255, 0.7); text-decoration: none;">GitHub Documentation</a></span>
    </div>

    <!-- 改为CDN引用 -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/CSS2DRenderer.js"></script>
    <script>
        // 错误处理
        window.addEventListener('error', function(e) {
            console.error('JavaScript错误:', e.message);
            alert('发生错误: ' + e.message + '\n请检查控制台获取详细信息');
        });

        // Three.js 初始化和场景设置
        let scene, camera, renderer, labelRenderer, controls;
        let currentStep = 0;
        const steps = [];
        const chunks = [];
        const chunkObjects = [];
        const labels = [];
        const connections = [];
        let sphereMesh = null;
        let selectedChunk1 = null;
        let selectedChunk2 = null;
        let similarityLine = null;
        let similarityArc = null;
        let axesCreated = false;
        let centerCreated = false;
        let radiusLines = []; // 存储所有半径线，用于高亮显示
        let highlightedRadius1 = null;
        let highlightedRadius2 = null;
        let queryEmbedding = null;
        let queryVector = null;
        let queryRadius = null;
        let topK = 3;
        let similarityThreshold = 0.5;
        let selectionCone = null;
        let coneEdges = []; // 存储圆锥的边缘线
        let selectedChunksForRAG = [];
        
        // 颜色定义
        const colors = {
            input: 0x3498db,        // 蓝色 - 输入文本
            chunk: 0x2ecc71,        // 绿色 - 文本块
            embedding: 0x9b59b6,   // 紫色 - Embedding向量
            sphere: 0x34495e,      // 深蓝灰色 - 球体
            selected: 0xffcc00,    // 黄色 - 选中的chunk
            similarity: 0xe74c3c,  // 红色 - 相似度连线
            query: 0xf39c12        // 橙色 - 查询向量
        };
        
        // 查询文本（用于RAG演示）
        const queryText = "什么是注意力机制？";
        
        // 示例知识库文本块 - 重新设计位置，让一些与查询相关，一些不相关
        // 查询是关于"注意力机制"的，所以相关的chunk应该靠近查询向量
        // 相关性范围：0.9-0.95（高度相关），0.7-0.85（中等相关），0.3-0.6（低相关），0.0-0.2（不相关）
        const knowledgeChunks = [
            {
                id: 1,
                title: "注意力机制",
                content: "注意力机制允许模型在处理序列时关注不同位置的信息，通过计算查询、键和值之间的相似度来分配权重。",
                relevance: 0.95  // 高度相关 - 直接相关
            },
            {
                id: 2,
                title: "多头注意力",
                content: "多头注意力机制可以并行处理多个注意力子空间，每个头学习不同的表示，然后将结果拼接起来。",
                relevance: 0.88  // 高度相关 - 直接相关
            },
            {
                id: 3,
                title: "自注意力",
                content: "自注意力机制是注意力机制的一种特殊形式，允许序列中的每个位置关注序列中的所有位置，包括自身。",
                relevance: 0.82  // 高度相关 - 直接相关
            },
            {
                id: 4,
                title: "Transformer架构",
                content: "Transformer模型是一种基于注意力机制的深度学习架构，由编码器和解码器组成，完全摒弃了循环和卷积结构。",
                relevance: 0.75  // 中等相关 - 使用注意力机制
            },
            {
                id: 5,
                title: "位置编码",
                content: "位置编码用于为序列中的每个位置提供位置信息，因为Transformer没有循环结构，需要通过位置编码来理解顺序。",
                relevance: 0.55  // 中等相关 - Transformer相关但非注意力核心
            },
            {
                id: 6,
                title: "前馈网络",
                content: "前馈神经网络是Transformer中的另一个重要组件，通常包含两个线性变换和一个激活函数，用于处理注意力机制的输出。",
                relevance: 0.45  // 低相关 - Transformer组件但非注意力
            },
            {
                id: 7,
                title: "层归一化",
                content: "Layer Normalization有助于稳定训练过程，通过对每个样本的特征进行归一化来减少内部协变量偏移。",
                relevance: 0.30  // 低相关 - 通用技术
            },
            {
                id: 8,
                title: "残差连接",
                content: "残差连接可以缓解深层网络的梯度消失问题，允许梯度直接传播到前面的层，使得训练更深的网络成为可能。",
                relevance: 0.25  // 低相关 - 通用技术
            },
            {
                id: 9,
                title: "BERT模型",
                content: "BERT模型使用双向Transformer编码器进行预训练，通过掩码语言模型和下一句预测任务学习语言表示。",
                relevance: 0.40  // 低相关 - 使用Transformer但重点不在注意力
            },
            {
                id: 10,
                title: "图像分类",
                content: "图像分类是计算机视觉中的基本任务，通过训练深度神经网络来识别和分类图像中的对象。",
                relevance: 0.05  // 不相关 - 完全不同领域
            },
            {
                id: 11,
                title: "自然语言处理",
                content: "自然语言处理是人工智能的一个分支，致力于让计算机理解和处理人类语言。",
                relevance: 0.15  // 不相关 - 相关领域但主题不同
            },
            {
                id: 12,
                title: "强化学习",
                content: "强化学习是一种机器学习方法，通过与环境交互来学习最优策略，常用于游戏AI和机器人控制。",
                relevance: 0.02  // 不相关 - 完全不同领域
            }
        ];
        
        // 步骤描述
        const stepDescriptions = [
            "步骤1: 输入查询文本，系统将文本进行预处理和分块。",
            "步骤2: 将文本块转换为高维向量（Embedding），每个chunk对应一个向量。",
            "步骤3: 将所有向量归一化后分布在单位球面上，展示向量空间分布。",
            "步骤4: 输入查询文本，将查询转换为embedding向量并显示在球面上。",
            "步骤5: 计算查询向量与所有chunk的相似度，根据top-K参数选择最相关的chunk。",
            "步骤6: 展示检索到的chunk，用于RAG生成答案。"
        ];
        
        // 初始化 Three.js 场景
        function init() {
            if (typeof THREE === 'undefined') {
                console.error('错误: Three.js未加载!');
                alert('Three.js库未正确加载，请检查网络连接或引用路径');
                return;
            }
            
            try {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x121212);
                
                // 创建相机
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 15);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas').appendChild(renderer.domElement);
                
                // 创建CSS2D渲染器用于标签
                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('canvas').appendChild(labelRenderer.domElement);
                
                // 添加控制
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight1.position.set(1, 1, 1);
                scene.add(directionalLight1);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight2.position.set(-1, -1, -1);
                scene.add(directionalLight2);
                
                // 初始化射线投射器和鼠标向量
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // 初始化tooltip
                tooltip = document.getElementById('tooltip');
                
                // 窗口大小调整
                window.addEventListener('resize', onWindowResize, false);
                
                // 设置按钮事件
                document.getElementById('start-btn').addEventListener('click', startDemo);
                document.getElementById('prev-btn').addEventListener('click', prevStep);
                document.getElementById('next-btn').addEventListener('click', nextStep);
                document.getElementById('reset-btn').addEventListener('click', resetDemo);
                
                // 添加鼠标事件
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('click', onClick);
                
                // 添加查询转换按钮事件
                document.getElementById('convert-query-btn').addEventListener('click', function() {
                    if (currentStep === 3) {
                        nextStep(); // 自动进入下一步
                    }
                });
                
                // 创建动画步骤
                createSteps();
                
                // 开始渲染循环
                animate();
                
                console.log('Three.js初始化成功');
            } catch (error) {
                console.error('初始化Three.js时出错:', error);
                alert('初始化三维场景时发生错误，请检查控制台获取详情');
            }
        }
        
        // 创建所有动画步骤
        function createSteps() {
            // 步骤1: 展示输入文本和分块
            steps.push(() => {
                clearScene();
                showInputText();
                updateDescription(0);
            });
            
            // 步骤2: 展示文本分块
            steps.push(() => {
                showChunks();
                updateDescription(1);
            });
            
            // 步骤3: 展示Embedding和球面分布（根据相关性分布）
            steps.push(() => {
                showEmbeddingsOnSphere();
                updateDescription(2);
            });
            
            // 步骤4: 输入查询并转换为embedding向量
            steps.push(() => {
                showQueryInput();
                updateDescription(3);
            });
            
            // 步骤5: 展示查询向量在球面上，并计算相似度
            steps.push(() => {
                showQueryEmbedding();
                updateDescription(4);
            });
            
            // 步骤6: 根据top-K选择chunk并展示RAG结果
            steps.push(() => {
                showRAGSelection();
                updateDescription(5);
            });
        }
        
        // 步骤1: 展示输入文本
        function showInputText() {
            const queryText = "什么是注意力机制？";
            
            // 创建输入文本标签
            const inputLabelDiv = document.createElement('div');
            inputLabelDiv.className = 'label';
            inputLabelDiv.textContent = `查询: ${queryText}`;
            inputLabelDiv.style.fontSize = '18px';
            inputLabelDiv.style.fontWeight = 'bold';
            inputLabelDiv.style.color = '#3498db';
            
            const inputLabel = new THREE.CSS2DObject(inputLabelDiv);
            inputLabel.position.set(0, 8, 0);
            scene.add(inputLabel);
            labels.push(inputLabel);
        }
        
        // 步骤2: 展示文本分块
        function showChunks() {
            chunks.length = 0;
            chunkObjects.length = 0;
            
            // 创建文本块
            knowledgeChunks.forEach((chunkData, index) => {
                const chunkGeometry = new THREE.BoxGeometry(2, 0.5, 0.2);
                const chunkMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.chunk,
                    transparent: true,
                    opacity: 0.8
                });
                const chunk = new THREE.Mesh(chunkGeometry, chunkMaterial);
                
                // 水平排列
                chunk.position.x = (index - (knowledgeChunks.length - 1) / 2) * 2.5;
                chunk.position.y = 5;
                chunk.position.z = 0;
                
                chunk.userData.type = 'chunk';
                chunk.userData.id = index;
                chunk.userData.text = chunkData.content;
                chunk.userData.title = chunkData.title;
                
                scene.add(chunk);
                chunkObjects.push(chunk);
                chunks.push({
                    id: index,
                    obj: chunk,
                    text: chunkData.content,
                    title: chunkData.title,
                    embedding: null
                });
                
                // 添加文本标签（显示标题）
                const labelDiv = document.createElement('div');
                labelDiv.className = 'chunk-label';
                labelDiv.textContent = chunkData.title;
                
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, -0.5, 0);
                chunk.add(label);
                labels.push(label);
            });
        }
        
        // 步骤3: 展示Embedding和球面分布（根据相关性分布）
        function showEmbeddingsOnSphere() {
            // 清除之前的chunk对象
            chunkObjects.forEach(chunk => {
                scene.remove(chunk);
            });
            chunkObjects.length = 0;
            
            // 创建坐标轴
            createCoordinateAxes();
            
            // 创建圆心标记
            createCenterPoint();
            
            // 创建wireframe球体
            const sphereRadius = 5;
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.sphere,
                transparent: true,
                opacity: 0.3,
                wireframe: true,  // 使用wireframe模式
                side: THREE.DoubleSide
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphereMesh);
            
            // 定义查询向量的方向（用于计算相关性位置）
            // 查询向量将位于 (1, 0, 0) 方向（X轴正方向）
            const queryDirection = new THREE.Vector3(1, 0, 0);
            
            // 为每个chunk生成embedding向量，根据相关性分布
            // 相关性高的chunk应该集中在查询向量附近（夹角小）
            // 相关性低的chunk应该分散在远离查询向量的位置（夹角大）
            chunks.forEach((chunk, index) => {
                const chunkData = knowledgeChunks[index];
                const relevance = chunkData.relevance || 0.5;
                
                // 根据相关性计算与查询向量的夹角
                // 相关性高 -> 夹角小（靠近查询方向）
                // 相关性低 -> 夹角大（远离查询方向）
                // cos(夹角) = 相关性，所以夹角 = arccos(相关性)
                const angleFromQuery = Math.acos(Math.max(-1, Math.min(1, relevance)));
                
                // 为了更好的可视化效果，让相关性高的chunk更集中
                // 在垂直于查询方向的平面上选择一个方向
                // 使用index来确保分布均匀但可预测
                const randomAngle = (index / knowledgeChunks.length) * Math.PI * 2;
                
                // 创建一个垂直于查询方向的向量
                let perpendicular;
                if (Math.abs(queryDirection.x) < 0.9) {
                    perpendicular = new THREE.Vector3(1, 0, 0);
                } else {
                    perpendicular = new THREE.Vector3(0, 1, 0);
                }
                perpendicular.crossVectors(perpendicular, queryDirection).normalize();
                
                // 绕查询方向旋转perpendicular向量
                const quaternion = new THREE.Quaternion().setFromAxisAngle(queryDirection, randomAngle);
                perpendicular.applyQuaternion(quaternion);
                
                // 现在在包含查询方向和perpendicular的平面内，从查询方向旋转angleFromQuery角度
                const rotationAxis = new THREE.Vector3().crossVectors(queryDirection, perpendicular).normalize();
                const embeddingQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angleFromQuery);
                const embedding = queryDirection.clone().applyQuaternion(embeddingQuaternion);
                
                // 存储归一化向量
                chunk.embedding = embedding.normalize();
                
                // 在球面上创建点
                const pointGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const pointMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.embedding,
                    emissive: new THREE.Color(colors.embedding),
                    emissiveIntensity: 0.3
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                
                // 位置在球面上
                point.position.set(
                    chunk.embedding.x * sphereRadius,
                    chunk.embedding.y * sphereRadius,
                    chunk.embedding.z * sphereRadius
                );
                
                point.userData.type = 'chunkPoint';
                point.userData.id = index;
                point.userData.text = chunk.text;
                point.userData.title = chunk.title;
                point.userData.embedding = chunk.embedding;
                point.userData.chunk = chunk;
                point.userData.relevance = relevance;
                
                scene.add(point);
                chunkObjects.push(point);
                
                // 添加标签（显示标题）
                const labelDiv = document.createElement('div');
                labelDiv.className = 'chunk-label';
                labelDiv.textContent = chunk.title;
                
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, 0.3, 0);
                point.add(label);
                labels.push(label);
                
                // 创建从原点到点的线（半径）
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    point.position.clone()
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.embedding,
                    transparent: true,
                    opacity: 0.3,
                    linewidth: 1
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.userData.type = 'radius';
                line.userData.chunkId = index;
                line.userData.chunkObj = point;
                scene.add(line);
                connections.push(line);
                radiusLines.push(line);
            });
            
            // 调整相机位置以更好地查看球体
            animateCameraMove({ x: 0, y: 0, z: 18 }, 1000);
        }
        
        // 创建坐标轴
        function createCoordinateAxes() {
            // 如果已经创建，跳过
            if (axesCreated) return;
            
            const axisLength = 6;
            const axisRadius = 0.05;
            
            // X轴 - 红色
            const xAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const xAxisMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
            xAxis.rotation.z = -Math.PI / 2;
            xAxis.position.x = axisLength / 2;
            scene.add(xAxis);
            
            // X轴箭头
            const xArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const xArrow = new THREE.Mesh(xArrowGeometry, xAxisMaterial);
            xArrow.rotation.z = -Math.PI / 2;
            xArrow.position.x = axisLength;
            scene.add(xArrow);
            
            // X轴标签
            const xLabelDiv = document.createElement('div');
            xLabelDiv.className = 'label';
            xLabelDiv.textContent = 'X';
            xLabelDiv.style.color = '#ff0000';
            xLabelDiv.style.fontSize = '20px';
            xLabelDiv.style.fontWeight = 'bold';
            const xLabel = new THREE.CSS2DObject(xLabelDiv);
            xLabel.position.set(axisLength + 0.5, 0, 0);
            scene.add(xLabel);
            labels.push(xLabel);
            
            // Y轴 - 绿色
            const yAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const yAxisMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
            yAxis.position.y = axisLength / 2;
            scene.add(yAxis);
            
            // Y轴箭头
            const yArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const yArrow = new THREE.Mesh(yArrowGeometry, yAxisMaterial);
            yArrow.rotation.x = Math.PI;
            yArrow.position.y = axisLength;
            scene.add(yArrow);
            
            // Y轴标签
            const yLabelDiv = document.createElement('div');
            yLabelDiv.className = 'label';
            yLabelDiv.textContent = 'Y';
            yLabelDiv.style.color = '#00ff00';
            yLabelDiv.style.fontSize = '20px';
            yLabelDiv.style.fontWeight = 'bold';
            const yLabel = new THREE.CSS2DObject(yLabelDiv);
            yLabel.position.set(0, axisLength + 0.5, 0);
            scene.add(yLabel);
            labels.push(yLabel);
            
            // Z轴 - 蓝色
            const zAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const zAxisMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
            zAxis.rotation.x = Math.PI / 2;
            zAxis.position.z = axisLength / 2;
            scene.add(zAxis);
            
            // Z轴箭头
            const zArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const zArrow = new THREE.Mesh(zArrowGeometry, zAxisMaterial);
            zArrow.rotation.x = -Math.PI / 2;
            zArrow.position.z = axisLength;
            scene.add(zArrow);
            
            // Z轴标签
            const zLabelDiv = document.createElement('div');
            zLabelDiv.className = 'label';
            zLabelDiv.textContent = 'Z';
            zLabelDiv.style.color = '#0000ff';
            zLabelDiv.style.fontSize = '20px';
            zLabelDiv.style.fontWeight = 'bold';
            const zLabel = new THREE.CSS2DObject(zLabelDiv);
            zLabel.position.set(0, 0, axisLength + 0.5);
            scene.add(zLabel);
            labels.push(zLabel);
            
            axesCreated = true;
        }
        
        // 创建圆心标记
        function createCenterPoint() {
            // 如果已经创建，跳过
            if (centerCreated) return;
            
            // 创建圆心球体
            const centerGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 0.5
            });
            const centerPoint = new THREE.Mesh(centerGeometry, centerMaterial);
            centerPoint.position.set(0, 0, 0);
            centerPoint.userData.type = 'center';
            scene.add(centerPoint);
            
            // 添加圆心标签
            const centerLabelDiv = document.createElement('div');
            centerLabelDiv.className = 'label';
            centerLabelDiv.textContent = 'O(0,0,0)';
            centerLabelDiv.style.color = '#ffffff';
            centerLabelDiv.style.fontSize = '14px';
            centerLabelDiv.style.fontWeight = 'bold';
            const centerLabel = new THREE.CSS2DObject(centerLabelDiv);
            centerLabel.position.set(0, -0.4, 0);
            centerPoint.add(centerLabel);
            labels.push(centerLabel);
            
            centerCreated = true;
        }
        
        // 步骤4: 启用相似度选择
        function enableSimilaritySelection() {
            // 确保坐标轴和圆心已创建
            createCoordinateAxes();
            createCenterPoint();
            
            document.getElementById('similarity-panel').style.display = 'block';
            
            // 默认选择前两个chunk进行演示
            if (chunkObjects.length >= 2) {
                selectChunkForSimilarity(chunkObjects[0], 0);
                setTimeout(() => {
                    selectChunkForSimilarity(chunkObjects[1], 1);
                }, 500);
            }
        }
        
        // 选择chunk进行相似度计算
        function selectChunkForSimilarity(chunkObj, selectionIndex) {
            if (selectionIndex === 0) {
                selectedChunk1 = chunkObj;
                highlightChunk(chunkObj, true);
            } else if (selectionIndex === 1) {
                selectedChunk2 = chunkObj;
                highlightChunk(chunkObj, true);
                
                // 计算并显示相似度
                if (selectedChunk1 && selectedChunk2) {
                    showSimilarity(selectedChunk1, selectedChunk2);
                }
            }
        }
        
        // 高亮chunk
        function highlightChunk(chunkObj, highlight) {
            if (highlight) {
                chunkObj.material.emissive = new THREE.Color(colors.selected);
                chunkObj.material.emissiveIntensity = 0.8;
                chunkObj.scale.setScalar(1.5);
            } else {
                chunkObj.material.emissive = new THREE.Color(colors.embedding);
                chunkObj.material.emissiveIntensity = 0.3;
                chunkObj.scale.setScalar(1.0);
            }
        }
        
        // 显示相似度
        function showSimilarity(chunk1, chunk2) {
            // 计算cos相似度（归一化向量的点积）
            const embedding1 = chunk1.userData.embedding;
            const embedding2 = chunk2.userData.embedding;
            const similarity = embedding1.dot(embedding2); // cos相似度
            
            // 计算角度（弧度转角度）
            const angle = Math.acos(Math.max(-1, Math.min(1, similarity))) * 180 / Math.PI;
            
            // 移除之前的相似度显示
            if (similarityLine) {
                scene.remove(similarityLine);
            }
            if (similarityArc) {
                scene.remove(similarityArc);
            }
            
            // 恢复之前高亮的半径线
            if (highlightedRadius1) {
                highlightedRadius1.material.color.setHex(colors.embedding);
                highlightedRadius1.material.opacity = 0.3;
                highlightedRadius1.material.linewidth = 1;
            }
            if (highlightedRadius2) {
                highlightedRadius2.material.color.setHex(colors.embedding);
                highlightedRadius2.material.opacity = 0.3;
                highlightedRadius2.material.linewidth = 1;
            }
            
            // 找到并高亮显示从原点到两个chunk的半径线
            const radius1 = radiusLines.find(line => line.userData.chunkId === chunk1.userData.id);
            const radius2 = radiusLines.find(line => line.userData.chunkId === chunk2.userData.id);
            
            if (radius1) {
                radius1.material.color.setHex(colors.selected);
                radius1.material.opacity = 1.0;
                radius1.material.linewidth = 3;
                highlightedRadius1 = radius1;
            }
            
            if (radius2) {
                radius2.material.color.setHex(colors.selected);
                radius2.material.opacity = 1.0;
                radius2.material.linewidth = 3;
                highlightedRadius2 = radius2;
            }
            
            // 创建两条半径线之间的夹角弧线（必须在两条半径线组成的平面内）
            // 使用球面线性插值（SLERP）确保弧线在平面内
            const arcRadius = 2.5; // 弧线半径
            const arcPoints = [];
            
            // 计算两个向量之间的夹角（弧度）
            const angleRad = Math.acos(Math.max(-1, Math.min(1, similarity)));
            
            // 使用球面线性插值（SLERP）在embedding1和embedding2之间插值
            // 这确保了弧线在包含这两个向量的平面内
            for (let i = 0; i <= 30; i++) {
                const t = i / 30;
                
                // 球面线性插值公式
                // SLERP(v1, v2, t) = (sin((1-t)*θ)/sin(θ)) * v1 + (sin(t*θ)/sin(θ)) * v2
                const sinTheta = Math.sin(angleRad);
                
                if (sinTheta < 0.001) {
                    // 如果角度很小（向量几乎平行），使用线性插值
                    const lerped = embedding1.clone().lerp(embedding2, t);
                    arcPoints.push(lerped.normalize().multiplyScalar(arcRadius));
                } else {
                    // 球面线性插值
                    const w1 = Math.sin((1 - t) * angleRad) / sinTheta;
                    const w2 = Math.sin(t * angleRad) / sinTheta;
                    const slerped = embedding1.clone().multiplyScalar(w1).add(embedding2.clone().multiplyScalar(w2));
                    arcPoints.push(slerped.normalize().multiplyScalar(arcRadius));
                }
            }
            
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMaterial = new THREE.LineBasicMaterial({ 
                color: colors.selected,
                transparent: true,
                opacity: 0.9,
                linewidth: 3
            });
            similarityArc = new THREE.Line(arcGeometry, arcMaterial);
            scene.add(similarityArc);
            
            // 更新相似度面板
            updateSimilarityPanel(chunk1, chunk2, similarity, angle);
        }
        
        // 更新相似度面板
        function updateSimilarityPanel(chunk1, chunk2, similarity, angle) {
            const panel = document.getElementById('similarity-content');
            panel.innerHTML = `
                <div class="similarity-item">
                    <div><strong>${chunk1.userData.title || `Chunk ${chunk1.userData.id + 1}`}</strong></div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">${chunk1.userData.text.substring(0, 60)}...</div>
                </div>
                <div class="similarity-item">
                    <div><strong>${chunk2.userData.title || `Chunk ${chunk2.userData.id + 1}`}</strong></div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">${chunk2.userData.text.substring(0, 60)}...</div>
                </div>
                <div class="similarity-item" style="text-align: center; margin-top: 15px;">
                    <div style="font-size: 14px; margin-bottom: 5px;">Cos 相似度</div>
                    <div class="similarity-value">${similarity.toFixed(3)}</div>
                    <div style="font-size: 14px; margin-top: 5px;">角度: ${angle.toFixed(1)}°</div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                        ${similarity > 0.8 ? '高度相似' : similarity > 0.5 ? '中等相似' : '低相似度'}
                    </div>
                </div>
            `;
        }
        
        // 步骤4: 显示查询输入面板
        function showQueryInput() {
            document.getElementById('query-input-panel').style.display = 'block';
        }
        
        // 步骤5: 展示查询向量转换和显示
        function showQueryEmbedding() {
            // 确保坐标轴和圆心已创建
            createCoordinateAxes();
            createCenterPoint();
            
            // 获取查询文本
            const inputText = document.getElementById('query-text-input').value || queryText;
            
            // 模拟查询向量转换（实际中会使用embedding模型）
            // 查询向量应该在X轴正方向附近（因为相关chunk也在那里）
            queryEmbedding = new THREE.Vector3(1, 0, 0).normalize();
            
            const sphereRadius = 5;
            
            // 创建查询向量点（动画显示）
            const queryPointGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const queryPointMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.query,
                emissive: new THREE.Color(colors.query),
                emissiveIntensity: 0.8
            });
            queryVector = new THREE.Mesh(queryPointGeometry, queryPointMaterial);
            
            // 初始位置在原点
            queryVector.position.set(0, 0, 0);
            queryVector.userData.type = 'query';
            queryVector.userData.embedding = queryEmbedding;
            queryVector.userData.text = inputText;
            scene.add(queryVector);
            
            // 添加查询标签
            const queryLabelDiv = document.createElement('div');
            queryLabelDiv.className = 'label';
            queryLabelDiv.textContent = '查询向量';
            queryLabelDiv.style.color = '#f39c12';
            queryLabelDiv.style.fontSize = '16px';
            queryLabelDiv.style.fontWeight = 'bold';
            
            const queryLabel = new THREE.CSS2DObject(queryLabelDiv);
            queryLabel.position.set(0, 0.5, 0);
            queryVector.add(queryLabel);
            labels.push(queryLabel);
            
            // 动画：从原点移动到球面
            animateObjectPosition(queryVector, {
                x: queryEmbedding.x * sphereRadius,
                y: queryEmbedding.y * sphereRadius,
                z: queryEmbedding.z * sphereRadius
            }, 1500, () => {
                // 创建从原点到查询点的半径线
                const queryRadiusGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    queryVector.position.clone()
                ]);
                const queryRadiusMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.query,
                    transparent: true,
                    opacity: 0.8,
                    linewidth: 3
                });
                queryRadius = new THREE.Line(queryRadiusGeometry, queryRadiusMaterial);
                scene.add(queryRadius);
                connections.push(queryRadius);
            });
        }
        
        // 步骤6: 展示RAG选择过程
        function showRAGSelection() {
            // 显示RAG控制面板
            document.getElementById('rag-controls').style.display = 'block';
            
            // 设置事件监听器
            setupRAGControls();
            
            // 执行RAG选择
            performRAGSelection();
        }
        
        // 设置RAG控制事件
        function setupRAGControls() {
            const topkSlider = document.getElementById('topk-slider');
            const thresholdSlider = document.getElementById('threshold-slider');
            
            topkSlider.addEventListener('input', function() {
                topK = parseInt(this.value);
                document.getElementById('topk-value').textContent = `当前值: ${topK}`;
                performRAGSelection();
            });
            
            thresholdSlider.addEventListener('input', function() {
                similarityThreshold = parseFloat(this.value);
                document.getElementById('threshold-value').textContent = `当前值: ${similarityThreshold.toFixed(2)}`;
                performRAGSelection();
            });
        }
        
        // 执行RAG选择
        function performRAGSelection() {
            if (!queryEmbedding) return;
            
            // 移除之前的圆锥边缘线（现在只使用线条，不使用solid圆锥）
            coneEdges.forEach(edge => {
                scene.remove(edge);
                const index = connections.indexOf(edge);
                if (index > -1) {
                    connections.splice(index, 1);
                }
            });
            coneEdges = [];
            
            // 如果还有旧的solid圆锥，也清除它
            if (selectionCone) {
                scene.remove(selectionCone);
                selectionCone = null;
            }
            selectedChunksForRAG.forEach(chunk => {
                highlightChunk(chunk, false);
            });
            selectedChunksForRAG = [];
            
            // 计算所有chunk与查询的相似度
            const similarities = chunks.map((chunk, index) => {
                const similarity = queryEmbedding.dot(chunk.embedding);
                return { index, similarity, chunk };
            });
            
            // 排序
            similarities.sort((a, b) => b.similarity - a.similarity);
            
            // 根据top-K和阈值选择
            const selected = similarities
                .filter(s => s.similarity >= similarityThreshold)
                .slice(0, topK);
            
            selectedChunksForRAG = selected.map(s => chunkObjects[s.index]);
            
            // 高亮选中的chunk
            selected.forEach((result, rank) => {
                const chunkObj = chunkObjects[result.index];
                highlightChunk(chunkObj, true);
                
                // 添加排名标签
                const rankLabelDiv = document.createElement('div');
                rankLabelDiv.className = 'label';
                rankLabelDiv.textContent = `#${rank + 1} (${result.similarity.toFixed(3)})`;
                rankLabelDiv.style.color = '#ffcc00';
                rankLabelDiv.style.fontSize = '14px';
                rankLabelDiv.style.fontWeight = 'bold';
                
                const rankLabel = new THREE.CSS2DObject(rankLabelDiv);
                rankLabel.position.set(0, -0.4, 0);
                chunkObj.add(rankLabel);
                labels.push(rankLabel);
            });
            
            // 创建圆锥可视化（顶点在圆心，沿查询向量方向）
            // 圆锥的半角 = arccos(最小相似度)
            // 如果选中的chunk数量少于topK，使用阈值；否则使用最后一个选中chunk的相似度
            let minSimilarity;
            if (selected.length > 0) {
                minSimilarity = selected[selected.length - 1].similarity;
            } else {
                // 如果没有选中的，使用阈值或top-K对应的相似度
                minSimilarity = similarities.length >= topK ? similarities[topK - 1].similarity : similarityThreshold;
            }
            
            // 确保最小相似度不低于阈值
            minSimilarity = Math.max(minSimilarity, similarityThreshold);
            
            const coneAngle = Math.acos(Math.max(-1, Math.min(1, minSimilarity)));
            
            createSelectionCone(queryEmbedding, coneAngle);
            
            // 更新信息面板
            updateRAGInfo(selected, similarities);
        }
        
        // 创建选择圆锥（顶点在圆心，沿查询向量方向）
        function createSelectionCone(direction, angle) {
            const sphereRadius = 5;
            
            // 确保方向向量已归一化
            const normalizedDirection = direction.clone().normalize();
            
            // 圆锥高度要足够高，确保与球面相交
            // 圆锥顶点在原点，需要延伸到球面外
            const coneHeight = sphereRadius * 2.5; // 足够高以覆盖球面
            const coneRadius = Math.tan(angle) * coneHeight;
            
            // 只创建wireframe圆锥，更清晰
            // 使用线条方式创建圆锥，而不是solid mesh
            const segments = 32;
            const edgePoints = [];
            
            // 创建圆锥底部的圆周点
            // 圆锥顶点在原点，沿着Y轴正方向延伸
            // 底部在 y = coneHeight 的位置
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const phi = t * Math.PI * 2;
                
                // 在圆锥底部圆周上的点（局部坐标系）
                // 圆锥沿着Y轴正方向，顶点在原点，底部在 y = coneHeight
                const localX = Math.cos(phi) * coneRadius;
                const localZ = Math.sin(phi) * coneRadius;
                const localY = coneHeight; // 底部在Y轴正方向
                
                const point = new THREE.Vector3(localX, localY, localZ);
                edgePoints.push(point);
            }
            
            // 计算旋转四元数：从Y轴正方向旋转到查询向量方向
            const up = new THREE.Vector3(0, 1, 0); // Y轴正方向（圆锥的初始方向）
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normalizedDirection);
            
            // 旋转所有边缘点
            edgePoints.forEach(point => {
                point.applyQuaternion(quaternion);
            });
            
            // 创建从原点到边缘的线（圆锥的母线）
            for (let i = 0; i < edgePoints.length - 1; i++) {
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0), // 原点（顶点）
                    edgePoints[i]
                ]);
                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: colors.query,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                const edgeLine = new THREE.Line(lineGeometry, edgeMaterial);
                scene.add(edgeLine);
                connections.push(edgeLine);
                coneEdges.push(edgeLine);
            }
            
            // 创建底部圆周线
            const circleGeometry = new THREE.BufferGeometry().setFromPoints(edgePoints);
            const circleMaterial = new THREE.LineBasicMaterial({
                color: colors.query,
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });
            const circleLine = new THREE.Line(circleGeometry, circleMaterial);
            scene.add(circleLine);
            connections.push(circleLine);
            coneEdges.push(circleLine);
            
            // 不再创建solid圆锥，只使用wireframe线条
            selectionCone = null; // 标记为null，因为我们不使用solid圆锥了
        }
        
        // 更新RAG信息面板
        function updateRAGInfo(selected, allSimilarities) {
            const infoPanel = document.getElementById('step-description');
            infoPanel.innerHTML = `
                ${stepDescriptions[5]}<br><br>
                <strong>查询:</strong> ${queryVector.userData.text}<br><br>
                <strong>Top-${topK} 检索结果:</strong><br>
                ${selected.map((r, i) => 
                    `${i + 1}. ${knowledgeChunks[r.index].title}: 相似度 ${r.similarity.toFixed(3)} (角度: ${(Math.acos(Math.max(-1, Math.min(1, r.similarity))) * 180 / Math.PI).toFixed(1)}°)`
                ).join('<br>')}<br><br>
                <strong>未选中的chunk:</strong><br>
                ${allSimilarities.slice(topK).map(r => 
                    `${knowledgeChunks[r.index].title}: ${r.similarity.toFixed(3)}`
                ).join(', ')}
            `;
        }
        
        // 旧函数保留（用于兼容）
        function showRetrievalResults() {
            // 确保坐标轴和圆心已创建
            createCoordinateAxes();
            createCenterPoint();
            
            // 模拟查询向量（查询文本也会被转换为embedding并归一化，所以也在单位球面上）
            // 查询向量代表用户的问题，例如："什么是注意力机制？"
            const queryEmbedding = new THREE.Vector3(0.5, 0.5, 0.7).normalize();
            
            // 创建查询点（查询向量也在单位球面上）
            const queryPointGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const queryPointMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.query,
                emissive: new THREE.Color(colors.query),
                emissiveIntensity: 0.8
            });
            const queryPoint = new THREE.Mesh(queryPointGeometry, queryPointMaterial);
            
            const sphereRadius = 5;
            queryPoint.position.set(
                queryEmbedding.x * sphereRadius,
                queryEmbedding.y * sphereRadius,
                queryEmbedding.z * sphereRadius
            );
            
            queryPoint.userData.type = 'query';
            queryPoint.userData.embedding = queryEmbedding;
            scene.add(queryPoint);
            
            // 添加查询标签
            const queryLabelDiv = document.createElement('div');
            queryLabelDiv.className = 'label';
            queryLabelDiv.textContent = '查询向量';
            queryLabelDiv.style.color = '#f39c12';
            queryLabelDiv.style.fontSize = '16px';
            queryLabelDiv.style.fontWeight = 'bold';
            
            const queryLabel = new THREE.CSS2DObject(queryLabelDiv);
            queryLabel.position.set(0, 0.5, 0);
            queryPoint.add(queryLabel);
            labels.push(queryLabel);
            
            // 创建从原点到查询点的半径线（高亮显示）
            const queryRadiusGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                queryPoint.position.clone()
            ]);
            const queryRadiusMaterial = new THREE.LineBasicMaterial({ 
                color: colors.query,
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });
            const queryRadius = new THREE.Line(queryRadiusGeometry, queryRadiusMaterial);
            scene.add(queryRadius);
            connections.push(queryRadius);
            
            // 计算所有chunk与查询的相似度
            const similarities = chunks.map((chunk, index) => {
                const similarity = queryEmbedding.dot(chunk.embedding);
                return { index, similarity, chunk };
            });
            
            // 排序并选择Top-3
            similarities.sort((a, b) => b.similarity - a.similarity);
            const topResults = similarities.slice(0, 3);
            
            // 高亮Top-3结果，并显示查询向量与它们的夹角
            topResults.forEach((result, rank) => {
                const chunkObj = chunkObjects[result.index];
                highlightChunk(chunkObj, true);
                
                // 创建从查询向量到结果的弧线（展示夹角）
                const chunkEmbedding = chunkObj.userData.embedding;
                const queryChunkAngle = Math.acos(Math.max(-1, Math.min(1, result.similarity)));
                const arcRadius = 2.0;
                const arcPoints = [];
                
                // 使用球面线性插值创建弧线
                const sinTheta = Math.sin(queryChunkAngle);
                if (sinTheta > 0.001) {
                    for (let i = 0; i <= 20; i++) {
                        const t = i / 20;
                        const w1 = Math.sin((1 - t) * queryChunkAngle) / sinTheta;
                        const w2 = Math.sin(t * queryChunkAngle) / sinTheta;
                        const slerped = queryEmbedding.clone().multiplyScalar(w1).add(chunkEmbedding.clone().multiplyScalar(w2));
                        arcPoints.push(slerped.normalize().multiplyScalar(arcRadius));
                    }
                    
                    const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
                    const arcMaterial = new THREE.LineBasicMaterial({ 
                        color: colors.query,
                        transparent: true,
                        opacity: 0.5,
                        linewidth: 2
                    });
                    const arc = new THREE.Line(arcGeometry, arcMaterial);
                    scene.add(arc);
                    connections.push(arc);
                }
                
                // 添加排名标签
                const rankLabelDiv = document.createElement('div');
                rankLabelDiv.className = 'label';
                rankLabelDiv.textContent = `#${rank + 1} 相似度:${result.similarity.toFixed(3)}`;
                rankLabelDiv.style.color = '#ffcc00';
                rankLabelDiv.style.fontSize = '14px';
                rankLabelDiv.style.fontWeight = 'bold';
                
                const rankLabel = new THREE.CSS2DObject(rankLabelDiv);
                rankLabel.position.set(0, -0.4, 0);
                chunkObj.add(rankLabel);
                labels.push(rankLabel);
            });
            
            // 更新信息面板
            const infoPanel = document.getElementById('step-description');
            infoPanel.innerHTML = `
                ${stepDescriptions[4]}<br><br>
                <strong>原理说明：</strong><br>
                查询文本也会被转换为embedding向量并归一化，因此查询向量也在单位球面上定位一个点。<br>
                系统计算查询向量与所有知识库chunk向量的cos相似度（夹角），相似度高的chunk被检索出来。<br><br>
                <strong>Top-3 检索结果:</strong><br>
                ${topResults.map((r, i) => 
                    `${i + 1}. ${knowledgeChunks[r.index].title}: 相似度 ${r.similarity.toFixed(3)} (角度: ${(Math.acos(Math.max(-1, Math.min(1, r.similarity))) * 180 / Math.PI).toFixed(1)}°)`
                ).join('<br>')}
            `;
        }
        
        // 鼠标移动事件
        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                if (obj.userData && obj.userData.type === 'chunkPoint') {
                    document.body.style.cursor = 'pointer';
                    
                    tooltip.innerHTML = `
                        <strong>${obj.userData.title || `Chunk ${obj.userData.id + 1}`}</strong><br>
                        ${obj.userData.text.substring(0, 80)}${obj.userData.text.length > 80 ? '...' : ''}<br>
                        <small>点击选择进行相似度比较</small>
                    `;
                    
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.style.display = 'block';
                }
            }
        }
        
        // 鼠标点击事件
        function onClick(event) {
            if (currentStep !== 3) return; // 只在步骤4生效
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                if (obj.userData && obj.userData.type === 'chunkPoint') {
                    if (!selectedChunk1) {
                        selectChunkForSimilarity(obj, 0);
                    } else if (!selectedChunk2 && obj !== selectedChunk1) {
                        selectChunkForSimilarity(obj, 1);
                    } else {
                        // 重置选择
                        if (selectedChunk1) highlightChunk(selectedChunk1, false);
                        if (selectedChunk2) highlightChunk(selectedChunk2, false);
                        
                        // 恢复半径线样式
                        if (highlightedRadius1) {
                            highlightedRadius1.material.color.setHex(colors.embedding);
                            highlightedRadius1.material.opacity = 0.3;
                            highlightedRadius1.material.linewidth = 1;
                        }
                        if (highlightedRadius2) {
                            highlightedRadius2.material.color.setHex(colors.embedding);
                            highlightedRadius2.material.opacity = 0.3;
                            highlightedRadius2.material.linewidth = 1;
                        }
                        
                        selectedChunk1 = null;
                        selectedChunk2 = null;
                        highlightedRadius1 = null;
                        highlightedRadius2 = null;
                        if (similarityLine) scene.remove(similarityLine);
                        if (similarityArc) scene.remove(similarityArc);
                        document.getElementById('similarity-content').innerHTML = '';
                        selectChunkForSimilarity(obj, 0);
                    }
                }
            }
        }
        
        // 其他辅助函数
        function updateDescription(stepIndex) {
            document.getElementById('step-description').textContent = stepDescriptions[stepIndex];
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 清理场景
        function clearScene() {
            while(scene.children.length > 0) { 
                const obj = scene.children[0];
                function removeAllChildren(object) {
                    while(object.children.length > 0) {
                        removeAllChildren(object.children[0]);
                        object.remove(object.children[0]);
                    }
                }
                removeAllChildren(obj);
                scene.remove(obj); 
            }
            
            chunks.length = 0;
            chunkObjects.length = 0;
            connections.length = 0;
            labels.length = 0;
            selectedChunk1 = null;
            selectedChunk2 = null;
            similarityLine = null;
            similarityArc = null;
            sphereMesh = null;
            axesCreated = false;
            centerCreated = false;
            radiusLines = [];
            highlightedRadius1 = null;
            highlightedRadius2 = null;
            
            // 重新添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);
            
            document.getElementById('similarity-panel').style.display = 'none';
            document.getElementById('query-input-panel').style.display = 'none';
            document.getElementById('rag-controls').style.display = 'none';
            
            queryEmbedding = null;
            queryVector = null;
            queryRadius = null;
            selectionCone = null;
            coneEdges = [];
            selectedChunksForRAG = [];
        }
        
        // 对象位置动画
        function animateObjectPosition(obj, targetPos, duration, callback) {
            const startPos = {
                x: obj.position.x,
                y: obj.position.y,
                z: obj.position.z
            };
            
            let startTime = null;
            
            function update(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = easeInOutCubic(progress);
                
                if (targetPos.x !== undefined) {
                    obj.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                }
                if (targetPos.y !== undefined) {
                    obj.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;
                }
                if (targetPos.z !== undefined) {
                    obj.position.z = startPos.z + (targetPos.z - startPos.z) * easeProgress;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                } else if (callback) {
                    callback();
                }
            }
            
            requestAnimationFrame(update);
        }
        
        // 相机移动动画
        function animateCameraMove(targetPos, duration) {
            const startPos = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };
            
            let startTime = null;
            
            function update(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = easeInOutCubic(progress);
                
                if (targetPos.x !== undefined) {
                    camera.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                }
                if (targetPos.y !== undefined) {
                    camera.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;
                }
                if (targetPos.z !== undefined) {
                    camera.position.z = startPos.z + (targetPos.z - startPos.z) * easeProgress;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }
        
        // 缓动函数
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // 开始演示
        function startDemo() {
            currentStep = 0;
            document.getElementById('start-btn').disabled = true;
            document.getElementById('next-btn').disabled = false;
            steps[currentStep]();
        }
        
        // 下一步
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                steps[currentStep]();
                document.getElementById('prev-btn').disabled = false;
                if (currentStep === steps.length - 1) {
                    document.getElementById('next-btn').disabled = true;
                }
            }
        }
        
        // 上一步
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                clearScene();
                for (let i = 0; i <= currentStep; i++) {
                    steps[i]();
                }
                if (currentStep === 0) {
                    document.getElementById('prev-btn').disabled = true;
                }
                document.getElementById('next-btn').disabled = false;
            }
        }
        
        // 重置演示
        function resetDemo() {
            currentStep = -1;
            clearScene();
            camera.position.set(0, 0, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('prev-btn').disabled = true;
            document.getElementById('next-btn').disabled = true;
            document.getElementById('step-description').textContent = 
                '欢迎来到AI知识库流程可视化！点击"开始"按钮开始演示。';
        }
        
        // 页面加载完成后初始化
        window.onload = init;
    </script>
</body>
</html>
