<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 知识库流程可视化</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas { 
            width: 100%; 
            height: 100%;
            position: fixed;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
            font-size: 16px;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
        }
        .step-btn {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
        }
        .step-btn:hover {
            background: #2980b9;
        }
        .step-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .label {
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 5px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            font-size: 14px;
            pointer-events: none;
        }
        .chunk-label {
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 5px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            max-width: 150px;
            word-wrap: break-word;
        }
        #copyright {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-family: Arial, sans-serif;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #copyright a {
            pointer-events: auto;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 300px;
        }
        
        .chunk-point {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .chunk-point:hover {
            transform: scale(1.2);
        }
        
        .chunk-point.selected {
            box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.8);
        }
        
        #similarity-panel {
            position: absolute;
            top: 85px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
            width: 300px;
        }
        
        .similarity-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        
        .similarity-value {
            color: #ffcc00;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <div id="info">
        <h2>AI 知识库流程可视化</h2>
        <p id="step-description">欢迎来到AI知识库流程可视化！点击"开始"按钮开始演示。</p>
    </div>
    <div id="controls">
        <button class="step-btn" id="start-btn">开始</button>
        <button class="step-btn" id="prev-btn" disabled>上一步</button>
        <button class="step-btn" id="next-btn" disabled>下一步</button>
        <button class="step-btn" id="reset-btn">重置</button>
    </div>
    
    <div id="similarity-panel">
        <h3>相似度信息</h3>
        <div id="similarity-content"></div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <!-- Add copyright information at the end of the body -->
    <div id="copyright">
        <span>© Senparc</span>
        <span> | <a href="https://github.com/Senparc/Senparc.AI/tree/main/documents/AI-Knowledge/Transformer" target="_blank" style="color: rgba(255, 255, 255, 0.7); text-decoration: none;">GitHub Documentation</a></span>
    </div>

    <!-- 改为CDN引用 -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/CSS2DRenderer.js"></script>
    <script>
        // 错误处理
        window.addEventListener('error', function(e) {
            console.error('JavaScript错误:', e.message);
            alert('发生错误: ' + e.message + '\n请检查控制台获取详细信息');
        });

        // Three.js 初始化和场景设置
        let scene, camera, renderer, labelRenderer, controls;
        let currentStep = 0;
        const steps = [];
        const chunks = [];
        const chunkObjects = [];
        const labels = [];
        const connections = [];
        let sphereMesh = null;
        let selectedChunk1 = null;
        let selectedChunk2 = null;
        let similarityLine = null;
        let similarityArc = null;
        let axesCreated = false;
        let centerCreated = false;
        let radiusLines = []; // 存储所有半径线，用于高亮显示
        let highlightedRadius1 = null;
        let highlightedRadius2 = null;
        
        // 颜色定义
        const colors = {
            input: 0x3498db,        // 蓝色 - 输入文本
            chunk: 0x2ecc71,        // 绿色 - 文本块
            embedding: 0x9b59b6,   // 紫色 - Embedding向量
            sphere: 0x34495e,      // 深蓝灰色 - 球体
            selected: 0xffcc00,    // 黄色 - 选中的chunk
            similarity: 0xe74c3c,  // 红色 - 相似度连线
            query: 0xf39c12        // 橙色 - 查询向量
        };
        
        // 示例知识库文本块 - 使用更真实的chunk内容
        const knowledgeChunks = [
            {
                id: 1,
                title: "Transformer架构",
                content: "Transformer模型是一种基于注意力机制的深度学习架构，由编码器和解码器组成，完全摒弃了循环和卷积结构。"
            },
            {
                id: 2,
                title: "注意力机制",
                content: "注意力机制允许模型在处理序列时关注不同位置的信息，通过计算查询、键和值之间的相似度来分配权重。"
            },
            {
                id: 3,
                title: "多头注意力",
                content: "多头注意力机制可以并行处理多个注意力子空间，每个头学习不同的表示，然后将结果拼接起来。"
            },
            {
                id: 4,
                title: "位置编码",
                content: "位置编码用于为序列中的每个位置提供位置信息，因为Transformer没有循环结构，需要通过位置编码来理解顺序。"
            },
            {
                id: 5,
                title: "前馈网络",
                content: "前馈神经网络是Transformer中的另一个重要组件，通常包含两个线性变换和一个激活函数，用于处理注意力机制的输出。"
            },
            {
                id: 6,
                title: "层归一化",
                content: "Layer Normalization有助于稳定训练过程，通过对每个样本的特征进行归一化来减少内部协变量偏移。"
            },
            {
                id: 7,
                title: "残差连接",
                content: "残差连接可以缓解深层网络的梯度消失问题，允许梯度直接传播到前面的层，使得训练更深的网络成为可能。"
            },
            {
                id: 8,
                title: "BERT模型",
                content: "BERT模型使用双向Transformer编码器进行预训练，通过掩码语言模型和下一句预测任务学习语言表示。"
            }
        ];
        
        // 步骤描述
        const stepDescriptions = [
            "步骤1: 输入查询文本，系统将文本进行预处理和分块。",
            "步骤2: 将文本块转换为高维向量（Embedding），每个chunk对应一个向量。",
            "步骤3: 将所有向量归一化后分布在单位球面上，展示向量空间分布。",
            "步骤4: 选择两个chunk，通过它们对应的半径夹角展示cos相似度。",
            "步骤5: 根据相似度检索最相关的知识库内容。"
        ];
        
        // 初始化 Three.js 场景
        function init() {
            if (typeof THREE === 'undefined') {
                console.error('错误: Three.js未加载!');
                alert('Three.js库未正确加载，请检查网络连接或引用路径');
                return;
            }
            
            try {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x121212);
                
                // 创建相机
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 15);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas').appendChild(renderer.domElement);
                
                // 创建CSS2D渲染器用于标签
                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('canvas').appendChild(labelRenderer.domElement);
                
                // 添加控制
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight1.position.set(1, 1, 1);
                scene.add(directionalLight1);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight2.position.set(-1, -1, -1);
                scene.add(directionalLight2);
                
                // 初始化射线投射器和鼠标向量
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // 初始化tooltip
                tooltip = document.getElementById('tooltip');
                
                // 窗口大小调整
                window.addEventListener('resize', onWindowResize, false);
                
                // 设置按钮事件
                document.getElementById('start-btn').addEventListener('click', startDemo);
                document.getElementById('prev-btn').addEventListener('click', prevStep);
                document.getElementById('next-btn').addEventListener('click', nextStep);
                document.getElementById('reset-btn').addEventListener('click', resetDemo);
                
                // 添加鼠标事件
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('click', onClick);
                
                // 创建动画步骤
                createSteps();
                
                // 开始渲染循环
                animate();
                
                console.log('Three.js初始化成功');
            } catch (error) {
                console.error('初始化Three.js时出错:', error);
                alert('初始化三维场景时发生错误，请检查控制台获取详情');
            }
        }
        
        // 创建所有动画步骤
        function createSteps() {
            // 步骤1: 展示输入文本和分块
            steps.push(() => {
                clearScene();
                showInputText();
                updateDescription(0);
            });
            
            // 步骤2: 展示文本分块
            steps.push(() => {
                showChunks();
                updateDescription(1);
            });
            
            // 步骤3: 展示Embedding和球面分布
            steps.push(() => {
                showEmbeddingsOnSphere();
                updateDescription(2);
            });
            
            // 步骤4: 展示相似度计算
            steps.push(() => {
                enableSimilaritySelection();
                updateDescription(3);
            });
            
            // 步骤5: 展示检索结果
            steps.push(() => {
                showRetrievalResults();
                updateDescription(4);
            });
        }
        
        // 步骤1: 展示输入文本
        function showInputText() {
            const queryText = "什么是注意力机制？";
            
            // 创建输入文本标签
            const inputLabelDiv = document.createElement('div');
            inputLabelDiv.className = 'label';
            inputLabelDiv.textContent = `查询: ${queryText}`;
            inputLabelDiv.style.fontSize = '18px';
            inputLabelDiv.style.fontWeight = 'bold';
            inputLabelDiv.style.color = '#3498db';
            
            const inputLabel = new THREE.CSS2DObject(inputLabelDiv);
            inputLabel.position.set(0, 8, 0);
            scene.add(inputLabel);
            labels.push(inputLabel);
        }
        
        // 步骤2: 展示文本分块
        function showChunks() {
            chunks.length = 0;
            chunkObjects.length = 0;
            
            // 创建文本块
            knowledgeChunks.forEach((chunkData, index) => {
                const chunkGeometry = new THREE.BoxGeometry(2, 0.5, 0.2);
                const chunkMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.chunk,
                    transparent: true,
                    opacity: 0.8
                });
                const chunk = new THREE.Mesh(chunkGeometry, chunkMaterial);
                
                // 水平排列
                chunk.position.x = (index - (knowledgeChunks.length - 1) / 2) * 2.5;
                chunk.position.y = 5;
                chunk.position.z = 0;
                
                chunk.userData.type = 'chunk';
                chunk.userData.id = index;
                chunk.userData.text = chunkData.content;
                chunk.userData.title = chunkData.title;
                
                scene.add(chunk);
                chunkObjects.push(chunk);
                chunks.push({
                    id: index,
                    obj: chunk,
                    text: chunkData.content,
                    title: chunkData.title,
                    embedding: null
                });
                
                // 添加文本标签（显示标题）
                const labelDiv = document.createElement('div');
                labelDiv.className = 'chunk-label';
                labelDiv.textContent = chunkData.title;
                
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, -0.5, 0);
                chunk.add(label);
                labels.push(label);
            });
        }
        
        // 步骤3: 展示Embedding和球面分布
        function showEmbeddingsOnSphere() {
            // 清除之前的chunk对象
            chunkObjects.forEach(chunk => {
                scene.remove(chunk);
            });
            chunkObjects.length = 0;
            
            // 创建坐标轴
            createCoordinateAxes();
            
            // 创建圆心标记
            createCenterPoint();
            
            // 创建wireframe球体
            const sphereRadius = 5;
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.sphere,
                transparent: true,
                opacity: 0.3,
                wireframe: true,  // 使用wireframe模式
                side: THREE.DoubleSide
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphereMesh);
            
            // 为每个chunk生成随机但稳定的embedding向量（归一化）
            chunks.forEach((chunk, index) => {
                // 生成一个在球面上均匀分布的向量
                const theta = (index / knowledgeChunks.length) * Math.PI * 2; // 方位角
                const phi = Math.acos(2 * (index / knowledgeChunks.length) - 1); // 极角（均匀分布）
                
                // 转换为笛卡尔坐标（归一化向量）
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.sin(phi) * Math.sin(theta);
                const z = Math.cos(phi);
                
                // 存储归一化向量
                chunk.embedding = new THREE.Vector3(x, y, z);
                
                // 在球面上创建点
                const pointGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const pointMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.embedding,
                    emissive: new THREE.Color(colors.embedding),
                    emissiveIntensity: 0.3
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                
                // 位置在球面上
                point.position.set(
                    x * sphereRadius,
                    y * sphereRadius,
                    z * sphereRadius
                );
                
                point.userData.type = 'chunkPoint';
                point.userData.id = index;
                point.userData.text = chunk.text;
                point.userData.title = chunk.title;
                point.userData.embedding = chunk.embedding;
                point.userData.chunk = chunk;
                
                scene.add(point);
                chunkObjects.push(point);
                
                // 添加标签（显示标题）
                const labelDiv = document.createElement('div');
                labelDiv.className = 'chunk-label';
                labelDiv.textContent = chunk.title;
                
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, 0.3, 0);
                point.add(label);
                labels.push(label);
                
                // 创建从原点到点的线（半径）
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    point.position.clone()
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.embedding,
                    transparent: true,
                    opacity: 0.3,
                    linewidth: 1
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.userData.type = 'radius';
                line.userData.chunkId = index;
                line.userData.chunkObj = point;
                scene.add(line);
                connections.push(line);
                radiusLines.push(line);
            });
            
            // 调整相机位置以更好地查看球体
            animateCameraMove({ x: 0, y: 0, z: 18 }, 1000);
        }
        
        // 创建坐标轴
        function createCoordinateAxes() {
            // 如果已经创建，跳过
            if (axesCreated) return;
            
            const axisLength = 6;
            const axisRadius = 0.05;
            
            // X轴 - 红色
            const xAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const xAxisMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
            xAxis.rotation.z = -Math.PI / 2;
            xAxis.position.x = axisLength / 2;
            scene.add(xAxis);
            
            // X轴箭头
            const xArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const xArrow = new THREE.Mesh(xArrowGeometry, xAxisMaterial);
            xArrow.rotation.z = -Math.PI / 2;
            xArrow.position.x = axisLength;
            scene.add(xArrow);
            
            // X轴标签
            const xLabelDiv = document.createElement('div');
            xLabelDiv.className = 'label';
            xLabelDiv.textContent = 'X';
            xLabelDiv.style.color = '#ff0000';
            xLabelDiv.style.fontSize = '20px';
            xLabelDiv.style.fontWeight = 'bold';
            const xLabel = new THREE.CSS2DObject(xLabelDiv);
            xLabel.position.set(axisLength + 0.5, 0, 0);
            scene.add(xLabel);
            labels.push(xLabel);
            
            // Y轴 - 绿色
            const yAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const yAxisMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
            yAxis.position.y = axisLength / 2;
            scene.add(yAxis);
            
            // Y轴箭头
            const yArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const yArrow = new THREE.Mesh(yArrowGeometry, yAxisMaterial);
            yArrow.rotation.x = Math.PI;
            yArrow.position.y = axisLength;
            scene.add(yArrow);
            
            // Y轴标签
            const yLabelDiv = document.createElement('div');
            yLabelDiv.className = 'label';
            yLabelDiv.textContent = 'Y';
            yLabelDiv.style.color = '#00ff00';
            yLabelDiv.style.fontSize = '20px';
            yLabelDiv.style.fontWeight = 'bold';
            const yLabel = new THREE.CSS2DObject(yLabelDiv);
            yLabel.position.set(0, axisLength + 0.5, 0);
            scene.add(yLabel);
            labels.push(yLabel);
            
            // Z轴 - 蓝色
            const zAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const zAxisMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
            zAxis.rotation.x = Math.PI / 2;
            zAxis.position.z = axisLength / 2;
            scene.add(zAxis);
            
            // Z轴箭头
            const zArrowGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const zArrow = new THREE.Mesh(zArrowGeometry, zAxisMaterial);
            zArrow.rotation.x = -Math.PI / 2;
            zArrow.position.z = axisLength;
            scene.add(zArrow);
            
            // Z轴标签
            const zLabelDiv = document.createElement('div');
            zLabelDiv.className = 'label';
            zLabelDiv.textContent = 'Z';
            zLabelDiv.style.color = '#0000ff';
            zLabelDiv.style.fontSize = '20px';
            zLabelDiv.style.fontWeight = 'bold';
            const zLabel = new THREE.CSS2DObject(zLabelDiv);
            zLabel.position.set(0, 0, axisLength + 0.5);
            scene.add(zLabel);
            labels.push(zLabel);
            
            axesCreated = true;
        }
        
        // 创建圆心标记
        function createCenterPoint() {
            // 如果已经创建，跳过
            if (centerCreated) return;
            
            // 创建圆心球体
            const centerGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 0.5
            });
            const centerPoint = new THREE.Mesh(centerGeometry, centerMaterial);
            centerPoint.position.set(0, 0, 0);
            centerPoint.userData.type = 'center';
            scene.add(centerPoint);
            
            // 添加圆心标签
            const centerLabelDiv = document.createElement('div');
            centerLabelDiv.className = 'label';
            centerLabelDiv.textContent = 'O(0,0,0)';
            centerLabelDiv.style.color = '#ffffff';
            centerLabelDiv.style.fontSize = '14px';
            centerLabelDiv.style.fontWeight = 'bold';
            const centerLabel = new THREE.CSS2DObject(centerLabelDiv);
            centerLabel.position.set(0, -0.4, 0);
            centerPoint.add(centerLabel);
            labels.push(centerLabel);
            
            centerCreated = true;
        }
        
        // 步骤4: 启用相似度选择
        function enableSimilaritySelection() {
            // 确保坐标轴和圆心已创建
            createCoordinateAxes();
            createCenterPoint();
            
            document.getElementById('similarity-panel').style.display = 'block';
            
            // 默认选择前两个chunk进行演示
            if (chunkObjects.length >= 2) {
                selectChunkForSimilarity(chunkObjects[0], 0);
                setTimeout(() => {
                    selectChunkForSimilarity(chunkObjects[1], 1);
                }, 500);
            }
        }
        
        // 选择chunk进行相似度计算
        function selectChunkForSimilarity(chunkObj, selectionIndex) {
            if (selectionIndex === 0) {
                selectedChunk1 = chunkObj;
                highlightChunk(chunkObj, true);
            } else if (selectionIndex === 1) {
                selectedChunk2 = chunkObj;
                highlightChunk(chunkObj, true);
                
                // 计算并显示相似度
                if (selectedChunk1 && selectedChunk2) {
                    showSimilarity(selectedChunk1, selectedChunk2);
                }
            }
        }
        
        // 高亮chunk
        function highlightChunk(chunkObj, highlight) {
            if (highlight) {
                chunkObj.material.emissive = new THREE.Color(colors.selected);
                chunkObj.material.emissiveIntensity = 0.8;
                chunkObj.scale.setScalar(1.5);
            } else {
                chunkObj.material.emissive = new THREE.Color(colors.embedding);
                chunkObj.material.emissiveIntensity = 0.3;
                chunkObj.scale.setScalar(1.0);
            }
        }
        
        // 显示相似度
        function showSimilarity(chunk1, chunk2) {
            // 计算cos相似度（归一化向量的点积）
            const embedding1 = chunk1.userData.embedding;
            const embedding2 = chunk2.userData.embedding;
            const similarity = embedding1.dot(embedding2); // cos相似度
            
            // 计算角度（弧度转角度）
            const angle = Math.acos(Math.max(-1, Math.min(1, similarity))) * 180 / Math.PI;
            
            // 移除之前的相似度显示
            if (similarityLine) {
                scene.remove(similarityLine);
            }
            if (similarityArc) {
                scene.remove(similarityArc);
            }
            
            // 恢复之前高亮的半径线
            if (highlightedRadius1) {
                highlightedRadius1.material.color.setHex(colors.embedding);
                highlightedRadius1.material.opacity = 0.3;
                highlightedRadius1.material.linewidth = 1;
            }
            if (highlightedRadius2) {
                highlightedRadius2.material.color.setHex(colors.embedding);
                highlightedRadius2.material.opacity = 0.3;
                highlightedRadius2.material.linewidth = 1;
            }
            
            // 找到并高亮显示从原点到两个chunk的半径线
            const radius1 = radiusLines.find(line => line.userData.chunkId === chunk1.userData.id);
            const radius2 = radiusLines.find(line => line.userData.chunkId === chunk2.userData.id);
            
            if (radius1) {
                radius1.material.color.setHex(colors.selected);
                radius1.material.opacity = 1.0;
                radius1.material.linewidth = 3;
                highlightedRadius1 = radius1;
            }
            
            if (radius2) {
                radius2.material.color.setHex(colors.selected);
                radius2.material.opacity = 1.0;
                radius2.material.linewidth = 3;
                highlightedRadius2 = radius2;
            }
            
            // 创建两条半径线之间的夹角弧线（必须在两条半径线组成的平面内）
            const arcRadius = 2.5; // 弧线半径
            const arcPoints = [];
            
            // 计算两个向量之间的夹角（弧度）
            const angleRad = Math.acos(Math.max(-1, Math.min(1, similarity)));
            
            // 计算两条半径线所在平面的法向量（垂直于这个平面）
            const cross = new THREE.Vector3().crossVectors(embedding1.clone(), embedding2.clone());
            const normal = cross.length() > 0.001 ? cross.normalize() : new THREE.Vector3(0, 0, 1);
            
            // 计算在平面内的旋转轴：垂直于embedding1，且在平面内
            // 旋转轴 = embedding1 × normal（这个向量在平面内，垂直于embedding1）
            let rotationAxis = new THREE.Vector3().crossVectors(embedding1.clone(), normal);
            
            // 如果rotationAxis长度太小，说明embedding1和normal平行，需要重新选择
            if (rotationAxis.length() < 0.001) {
                // 选择一个不在embedding1方向上的向量
                let tempVec;
                if (Math.abs(embedding1.x) < 0.9) {
                    tempVec = new THREE.Vector3(1, 0, 0);
                } else if (Math.abs(embedding1.y) < 0.9) {
                    tempVec = new THREE.Vector3(0, 1, 0);
                } else {
                    tempVec = new THREE.Vector3(0, 0, 1);
                }
                // 计算在平面内的向量（通过Gram-Schmidt过程）
                // 从tempVec中减去它在embedding1方向上的投影
                const proj = embedding1.clone().multiplyScalar(tempVec.dot(embedding1));
                rotationAxis = tempVec.clone().sub(proj).normalize();
            } else {
                rotationAxis.normalize();
            }
            
            // 在embedding1和embedding2所在的平面内创建弧线
            // 绕rotationAxis旋转embedding1，这样弧线就在平面内
            for (let i = 0; i <= 30; i++) {
                const t = i / 30;
                const currentAngle = t * angleRad;
                
                // 使用四元数绕rotationAxis旋转embedding1
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, currentAngle);
                const rotatedVector = embedding1.clone().applyQuaternion(quaternion);
                
                // 验证：确保旋转后的向量在平面内（与normal垂直）
                // const dot = rotatedVector.dot(normal);
                // console.log(`Point ${i}: dot with normal = ${dot.toFixed(6)}`); // 应该接近0
                
                // 将旋转后的向量缩放到弧线半径
                arcPoints.push(rotatedVector.multiplyScalar(arcRadius));
            }
            
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMaterial = new THREE.LineBasicMaterial({ 
                color: colors.selected,
                transparent: true,
                opacity: 0.9,
                linewidth: 3
            });
            similarityArc = new THREE.Line(arcGeometry, arcMaterial);
            scene.add(similarityArc);
            
            // 更新相似度面板
            updateSimilarityPanel(chunk1, chunk2, similarity, angle);
        }
        
        // 更新相似度面板
        function updateSimilarityPanel(chunk1, chunk2, similarity, angle) {
            const panel = document.getElementById('similarity-content');
            panel.innerHTML = `
                <div class="similarity-item">
                    <div><strong>${chunk1.userData.title || `Chunk ${chunk1.userData.id + 1}`}</strong></div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">${chunk1.userData.text.substring(0, 60)}...</div>
                </div>
                <div class="similarity-item">
                    <div><strong>${chunk2.userData.title || `Chunk ${chunk2.userData.id + 1}`}</strong></div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">${chunk2.userData.text.substring(0, 60)}...</div>
                </div>
                <div class="similarity-item" style="text-align: center; margin-top: 15px;">
                    <div style="font-size: 14px; margin-bottom: 5px;">Cos 相似度</div>
                    <div class="similarity-value">${similarity.toFixed(3)}</div>
                    <div style="font-size: 14px; margin-top: 5px;">角度: ${angle.toFixed(1)}°</div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                        ${similarity > 0.8 ? '高度相似' : similarity > 0.5 ? '中等相似' : '低相似度'}
                    </div>
                </div>
            `;
        }
        
        // 步骤5: 展示检索结果
        function showRetrievalResults() {
            // 确保坐标轴和圆心已创建
            createCoordinateAxes();
            createCenterPoint();
            
            // 模拟查询向量
            const queryEmbedding = new THREE.Vector3(0.5, 0.5, 0.7).normalize();
            
            // 创建查询点
            const queryPointGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const queryPointMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.query,
                emissive: new THREE.Color(colors.query),
                emissiveIntensity: 0.8
            });
            const queryPoint = new THREE.Mesh(queryPointGeometry, queryPointMaterial);
            
            const sphereRadius = 5;
            queryPoint.position.set(
                queryEmbedding.x * sphereRadius,
                queryEmbedding.y * sphereRadius,
                queryEmbedding.z * sphereRadius
            );
            
            queryPoint.userData.type = 'query';
            scene.add(queryPoint);
            
            // 添加查询标签
            const queryLabelDiv = document.createElement('div');
            queryLabelDiv.className = 'label';
            queryLabelDiv.textContent = '查询向量';
            queryLabelDiv.style.color = '#f39c12';
            
            const queryLabel = new THREE.CSS2DObject(queryLabelDiv);
            queryLabel.position.set(0, 0.4, 0);
            queryPoint.add(queryLabel);
            labels.push(queryLabel);
            
            // 计算所有chunk与查询的相似度
            const similarities = chunks.map((chunk, index) => {
                const similarity = queryEmbedding.dot(chunk.embedding);
                return { index, similarity, chunk };
            });
            
            // 排序并选择Top-3
            similarities.sort((a, b) => b.similarity - a.similarity);
            const topResults = similarities.slice(0, 3);
            
            // 高亮Top-3结果
            topResults.forEach((result, rank) => {
                const chunkObj = chunkObjects[result.index];
                highlightChunk(chunkObj, true);
                
                // 创建从查询到结果的连线
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    queryPoint.position.clone(),
                    chunkObj.position.clone()
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.query,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
                connections.push(line);
                
                // 添加排名标签
                const rankLabelDiv = document.createElement('div');
                rankLabelDiv.className = 'label';
                rankLabelDiv.textContent = `#${rank + 1} (${result.similarity.toFixed(2)})`;
                rankLabelDiv.style.color = '#ffcc00';
                rankLabelDiv.style.fontSize = '16px';
                
                const rankLabel = new THREE.CSS2DObject(rankLabelDiv);
                rankLabel.position.set(0, -0.4, 0);
                chunkObj.add(rankLabel);
                labels.push(rankLabel);
            });
            
            // 更新信息面板
            const infoPanel = document.getElementById('step-description');
            infoPanel.innerHTML = `
                ${stepDescriptions[4]}<br><br>
                <strong>Top-3 检索结果:</strong><br>
                ${topResults.map((r, i) => 
                    `${i + 1}. Chunk ${r.index + 1}: 相似度 ${r.similarity.toFixed(3)}`
                ).join('<br>')}
            `;
        }
        
        // 鼠标移动事件
        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                if (obj.userData && obj.userData.type === 'chunkPoint') {
                    document.body.style.cursor = 'pointer';
                    
                    tooltip.innerHTML = `
                        <strong>${obj.userData.title || `Chunk ${obj.userData.id + 1}`}</strong><br>
                        ${obj.userData.text.substring(0, 80)}${obj.userData.text.length > 80 ? '...' : ''}<br>
                        <small>点击选择进行相似度比较</small>
                    `;
                    
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.style.display = 'block';
                }
            }
        }
        
        // 鼠标点击事件
        function onClick(event) {
            if (currentStep !== 3) return; // 只在步骤4生效
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                if (obj.userData && obj.userData.type === 'chunkPoint') {
                    if (!selectedChunk1) {
                        selectChunkForSimilarity(obj, 0);
                    } else if (!selectedChunk2 && obj !== selectedChunk1) {
                        selectChunkForSimilarity(obj, 1);
                    } else {
                        // 重置选择
                        if (selectedChunk1) highlightChunk(selectedChunk1, false);
                        if (selectedChunk2) highlightChunk(selectedChunk2, false);
                        
                        // 恢复半径线样式
                        if (highlightedRadius1) {
                            highlightedRadius1.material.color.setHex(colors.embedding);
                            highlightedRadius1.material.opacity = 0.3;
                            highlightedRadius1.material.linewidth = 1;
                        }
                        if (highlightedRadius2) {
                            highlightedRadius2.material.color.setHex(colors.embedding);
                            highlightedRadius2.material.opacity = 0.3;
                            highlightedRadius2.material.linewidth = 1;
                        }
                        
                        selectedChunk1 = null;
                        selectedChunk2 = null;
                        highlightedRadius1 = null;
                        highlightedRadius2 = null;
                        if (similarityLine) scene.remove(similarityLine);
                        if (similarityArc) scene.remove(similarityArc);
                        document.getElementById('similarity-content').innerHTML = '';
                        selectChunkForSimilarity(obj, 0);
                    }
                }
            }
        }
        
        // 其他辅助函数
        function updateDescription(stepIndex) {
            document.getElementById('step-description').textContent = stepDescriptions[stepIndex];
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 清理场景
        function clearScene() {
            while(scene.children.length > 0) { 
                const obj = scene.children[0];
                function removeAllChildren(object) {
                    while(object.children.length > 0) {
                        removeAllChildren(object.children[0]);
                        object.remove(object.children[0]);
                    }
                }
                removeAllChildren(obj);
                scene.remove(obj); 
            }
            
            chunks.length = 0;
            chunkObjects.length = 0;
            connections.length = 0;
            labels.length = 0;
            selectedChunk1 = null;
            selectedChunk2 = null;
            similarityLine = null;
            similarityArc = null;
            sphereMesh = null;
            axesCreated = false;
            centerCreated = false;
            radiusLines = [];
            highlightedRadius1 = null;
            highlightedRadius2 = null;
            
            // 重新添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);
            
            document.getElementById('similarity-panel').style.display = 'none';
        }
        
        // 相机移动动画
        function animateCameraMove(targetPos, duration) {
            const startPos = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };
            
            let startTime = null;
            
            function update(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = easeInOutCubic(progress);
                
                if (targetPos.x !== undefined) {
                    camera.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                }
                if (targetPos.y !== undefined) {
                    camera.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;
                }
                if (targetPos.z !== undefined) {
                    camera.position.z = startPos.z + (targetPos.z - startPos.z) * easeProgress;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }
        
        // 缓动函数
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // 开始演示
        function startDemo() {
            currentStep = 0;
            document.getElementById('start-btn').disabled = true;
            document.getElementById('next-btn').disabled = false;
            steps[currentStep]();
        }
        
        // 下一步
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                steps[currentStep]();
                document.getElementById('prev-btn').disabled = false;
                if (currentStep === steps.length - 1) {
                    document.getElementById('next-btn').disabled = true;
                }
            }
        }
        
        // 上一步
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                clearScene();
                for (let i = 0; i <= currentStep; i++) {
                    steps[i]();
                }
                if (currentStep === 0) {
                    document.getElementById('prev-btn').disabled = true;
                }
                document.getElementById('next-btn').disabled = false;
            }
        }
        
        // 重置演示
        function resetDemo() {
            currentStep = -1;
            clearScene();
            camera.position.set(0, 0, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('prev-btn').disabled = true;
            document.getElementById('next-btn').disabled = true;
            document.getElementById('step-description').textContent = 
                '欢迎来到AI知识库流程可视化！点击"开始"按钮开始演示。';
        }
        
        // 页面加载完成后初始化
        window.onload = init;
    </script>
</body>
</html>
