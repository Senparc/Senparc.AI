<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Context Protocol 原理可视化</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas { 
            width: 100%; 
            height: 100%;
            position: fixed;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
            font-size: 16px;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
        }
        .step-btn {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
        }
        .step-btn#prev-btn{
            display: inline-block;
        }
        .label {
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 5px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            font-size: 20px;
            pointer-events: none;
        }
        #copyright {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-family: Arial, sans-serif;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #copyright a {
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <div id="info">
        <h2>Model Context Protocol 工作原理</h2>
        <p id="step-description">欢迎来到 MCP 模型可视化！点击"开始"按钮开始演示。</p>
    </div>
    <div id="controls">
        <button class="step-btn" id="start-btn">开始</button>
        <button class="step-btn" id="prev-btn" disabled>上一步</button>
        <button class="step-btn" id="next-btn" disabled>下一步</button>
        <button class="step-btn" id="reset-btn">重置</button>
    </div>

    <!-- 版权信息 -->
    <div id="copyright">
        <span>© Senparc</span>
        <span> | <a href="https://github.com/Senparc/Senparc.AI/tree/main/documemts/AI-Knowledge/Transformer" target="_blank" style="color: rgba(255, 255, 255, 0.7); text-decoration: none;">GitHub</a></span>
    </div>

    <!-- 引入本地 Three.js 文件 -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/CSS2DRenderer.js"></script>
    <script>
        // Three.js 初始化和场景设置
        let scene, camera, renderer, labelRenderer, controls;
        let currentStep = 0;
        const steps = [];
        const objects = [];
        const labels = [];
        const connections = [];
        
        // 实体颜色和形状定义
        const entityColors = {
            host: 0x3498db,      // 蓝色 - 主机应用
            client: 0xe74c3c,    // 红色 - 客户端
            server: 0xf39c12,    // 橙色 - 服务端
            localData: 0x2ecc71, // 绿色 - 本地数据
            remote: 0x9b59b6,    // 紫色 - 远程服务
            llm: 0x1abc9c,       // 青色 - LLM模型
            mcp: 0xffffff        // 白色 - MCP核心
        };
        
        // 形状类型常量
        const SHAPE_TYPES = {
            HOST: 'host',
            CLIENT: 'client',
            SERVER: 'server',
            DATA: 'data',
            REMOTE: 'remote',
            LLM: 'llm',
            MCP: 'mcp'
        };
        
        // 步骤描述
        const stepDescriptions = [
            "步骤 1: 初识 MCP - Model Context Protocol 是连接 AI 模型与数据、工具的标准协议。",
            "步骤 2: MCP 架构 - MCP 包含 Host、Client 和 Server 三个主要组件。",
            "步骤 3: Host 应用 - 如 Claude Desktop、IDE 等需要访问 MCP 数据的程序。",
            "步骤 4: Client 组件 - 协议客户端，与 Server 保持一对一连接。",
            "步骤 5: Server 组件 - 轻量级程序，通过 MCP 标准协议暴露特定功能。",
            "步骤 6: 数据连接 - MCP Server 可以安全访问本地数据源和远程服务。",
            "步骤 7: 实际工作流 - Host 发送请求，通过 Client 连接 Server，获取数据给 LLM 使用。"
        ];
        
        // 初始化 Three.js 场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas').appendChild(renderer.domElement);
            
            // 创建CSS2D渲染器用于标签
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.getElementById('canvas').appendChild(labelRenderer.domElement);
            
            // 添加控制
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize, false);
            
            // 设置按钮事件
            document.getElementById('start-btn').addEventListener('click', startDemo);
            document.getElementById('prev-btn').addEventListener('click', prevStep);
            document.getElementById('next-btn').addEventListener('click', nextStep);
            document.getElementById('reset-btn').addEventListener('click', resetDemo);
            
            // 创建动画步骤
            createSteps();
            
            // 开始渲染循环
            animate();
        }
        
        // 创建所有动画步骤
        function createSteps() {
            // 步骤1: MCP 介绍
            steps.push(() => {
                clearScene();
                showMCPIntroduction();
                updateDescription(0);
            });
            
            // 步骤2: MCP 架构
            steps.push(() => {
                clearScene();
                showMCPArchitecture();
                updateDescription(1);
            });
            
            // 步骤3: Host 应用
            steps.push(() => {
                clearScene();
                showHostApplications();
                updateDescription(2);
            });
            
            // 步骤4: Client 组件
            steps.push(() => {
                clearScene();
                showClientComponents();
                updateDescription(3);
            });
            
            // 步骤5: Server 组件
            steps.push(() => {
                clearScene();
                showServerComponents();
                updateDescription(4);
            });
            
            // 步骤6: 数据连接
            steps.push(() => {
                clearScene();
                showDataConnections();
                updateDescription(5);
            });
            
            // 步骤7: 完整工作流
            steps.push(() => {
                clearScene();
                showCompleteWorkflow();
                updateDescription(6);
            });
        }
        
        // 创建特定实体的统一形状
        function createEntity(type, name, x, y, z, scale = 1) {
            let mesh;
            const yOffset = 1.2 * scale; // 标签偏移量按比例调整
            
            switch(type) {
                case SHAPE_TYPES.MCP:
                    // MCP 核心 - 使用八面体
                    const mcpGeometry = new THREE.OctahedronGeometry(1 * scale, 0);
                    const mcpMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.mcp,
                        shininess: 100
                    });
                    mesh = new THREE.Mesh(mcpGeometry, mcpMaterial);
                    break;
                    
                case SHAPE_TYPES.HOST:
                    // Host 应用 - 使用稍微圆角的立方体
                    const hostGeometry = new THREE.BoxGeometry(1.5 * scale, 1.5 * scale, 1.5 * scale);
                    const hostMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.host
                    });
                    mesh = new THREE.Mesh(hostGeometry, hostMaterial);
                    break;
                    
                case SHAPE_TYPES.CLIENT:
                    // Client - 使用圆柱体
                    const clientGeometry = new THREE.CylinderGeometry(
                        0.9 * scale, 0.9 * scale, 1.5 * scale, 8
                    );
                    const clientMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.client
                    });
                    mesh = new THREE.Mesh(clientGeometry, clientMaterial);
                    break;
                    
                case SHAPE_TYPES.SERVER:
                    // Server - 使用六棱柱
                    const serverGeometry = new THREE.CylinderGeometry(
                        1 * scale, 1 * scale, 1.5 * scale, 6
                    );
                    const serverMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.server
                    });
                    mesh = new THREE.Mesh(serverGeometry, serverMaterial);
                    break;
                    
                case SHAPE_TYPES.DATA:
                    // 数据 - 使用四面体
                    const dataGeometry = new THREE.TetrahedronGeometry(1 * scale);
                    const dataMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.localData
                    });
                    mesh = new THREE.Mesh(dataGeometry, dataMaterial);
                    break;
                    
                case SHAPE_TYPES.REMOTE:
                    // 远程服务 - 使用球体
                    const remoteGeometry = new THREE.SphereGeometry(1 * scale, 16, 16);
                    const remoteMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.remote
                    });
                    mesh = new THREE.Mesh(remoteGeometry, remoteMaterial);
                    break;
                    
                case SHAPE_TYPES.LLM:
                    // LLM 模型 - 使用十二面体
                    const llmGeometry = new THREE.DodecahedronGeometry(1.2 * scale);
                    const llmMaterial = new THREE.MeshPhongMaterial({ 
                        color: entityColors.llm,
                        shininess: 80
                    });
                    mesh = new THREE.Mesh(llmGeometry, llmMaterial);
                    break;
                    
                default:
                    // 默认为方块
                    const defaultGeometry = new THREE.BoxGeometry(1 * scale, 1 * scale, 1 * scale);
                    const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                    mesh = new THREE.Mesh(defaultGeometry, defaultMaterial);
            }
            
            mesh.position.set(x, y, z);
            scene.add(mesh);
            objects.push(mesh);
            
            // 添加标签
            addTextLabel(mesh, name, yOffset);
            
            return mesh;
        }
        
        // MCP 介绍
        function showMCPIntroduction() {
            // 创建中心 MCP 实体
            const mcp = createEntity(SHAPE_TYPES.MCP, "MCP", 0, 0, 0, 1.5);
            
            // 创建周围的组件
            const llm = createEntity(SHAPE_TYPES.LLM, "AI 模型", 0, 5, 0);
            const data = createEntity(SHAPE_TYPES.DATA, "数据源", 5, 0, 0);
            const remote = createEntity(SHAPE_TYPES.REMOTE, "外部工具", -5, -2, 0);
            const host = createEntity(SHAPE_TYPES.HOST, "应用程序", -3, 3, 0);
            const server = createEntity(SHAPE_TYPES.SERVER, "API服务", 3, -4, 0);
            
            // 添加连接线
            createConnection(mcp, llm);
            createConnection(mcp, data);
            createConnection(mcp, remote);
            createConnection(mcp, host);
            createConnection(mcp, server);
        }
        
        // MCP 架构
        function showMCPArchitecture() {
            // 创建架构示意图
            const host = createEntity(SHAPE_TYPES.HOST, "Host", -6, 2, 0);
            const client = createEntity(SHAPE_TYPES.CLIENT, "Client", -3, 0, 0);
            const server = createEntity(SHAPE_TYPES.SERVER, "Server", 0, -2, 0);
            const data = createEntity(SHAPE_TYPES.DATA, "本地数据", 3, -3, 0);
            const remote = createEntity(SHAPE_TYPES.REMOTE, "远程服务", 6, -1, 0);
            
            // 添加连接线
            createConnection(host, client);
            createConnection(client, server);
            createConnection(server, data);
            createConnection(server, remote);
            
            // 添加 MCP 标签
            const mcpLabel = createTextLabel("Model Context Protocol", 0, 3, 0);
            // 添加描述性标签
            addFloatingLabel("标准化连接", -4.5, 1, 0);
            addFloatingLabel("数据访问", 1.5, -2.5, 0);
        }
        
        // Host 应用
        function showHostApplications() {
            const centerY = 0;
            
            // 创建中心 Host 组件
            const host = createEntity(SHAPE_TYPES.HOST, "Host", 0, centerY, 0, 1.6);
            
            // 创建各种 Host 类型
            const claude = createEntity(SHAPE_TYPES.HOST, "Claude Desktop", -5, centerY + 3, 0, 1.2);
            const ide = createEntity(SHAPE_TYPES.HOST, "IDE", -5, centerY, 0, 1.2);
            const aiTool = createEntity(SHAPE_TYPES.HOST, "AI 工具", -5, centerY - 3, 0, 1.2);
            
            // 连接到中心 Host
            createConnection(claude, host);
            createConnection(ide, host);
            createConnection(aiTool, host);
            
            // 添加 MCP Client 连接
            const client = createEntity(SHAPE_TYPES.CLIENT, "MCP Client", 5, centerY, 0);
            createConnection(host, client, entityColors.host);
        }
        
        // Client 组件
        function showClientComponents() {
            // 创建 Client 组件
            const client = createEntity(SHAPE_TYPES.CLIENT, "MCP Client", 0, 0, 0, 1.6);
            
            // 创建多个 Server 连接
            const fileServer = createEntity(SHAPE_TYPES.SERVER, "文件服务器", 5, 3, 0);
            const dbServer = createEntity(SHAPE_TYPES.SERVER, "数据库服务器", 5, 0, 0);
            const apiServer = createEntity(SHAPE_TYPES.SERVER, "API服务器", 5, -3, 0);
            
            // 创建 Host
            const host = createEntity(SHAPE_TYPES.HOST, "Host 应用", -5, 0, 0);
            
            // 添加连接线
            createConnection(host, client);
            createConnection(client, fileServer);
            createConnection(client, dbServer);
            createConnection(client, apiServer);
            
            // 添加标签，解释 1:1 连接
            addFloatingLabel("Client 与每个 Server 维持 1:1 连接", 0, 4, 0);
        }
        
        // Server 组件
        function showServerComponents() {
            // 创建 Server 组件
            const server = createEntity(SHAPE_TYPES.SERVER, "MCP Server", 0, 0, 0, 1.6);
            
            // 创建数据源
            const file = createEntity(SHAPE_TYPES.DATA, "文件系统", 4, 2, 0);
            const db = createEntity(SHAPE_TYPES.DATA, "本地数据库", 4, -2, 0);
            
            // 创建远程服务
            const api = createEntity(SHAPE_TYPES.REMOTE, "外部 API", -4, 2, 0);
            const service = createEntity(SHAPE_TYPES.REMOTE, "云服务", -4, -2, 0);
            
            // 添加连接线
            createConnection(server, file);
            createConnection(server, db);
            createConnection(server, api);
            createConnection(server, service);
            
            // 添加服务功能标签
            addFloatingLabel("暴露标准化能力", 0, 3, 0);
            addFloatingLabel("处理数据安全与权限", 0, -3, 0);
        }
        
        // 数据连接
        function showDataConnections() {
            // 创建本地数据
            const localData = createEntity(SHAPE_TYPES.DATA, "本地数据源", -4, 2, 0, 1.3);
            
            // 创建子项
            const files = createEntity(SHAPE_TYPES.DATA, "文件", -6, 4, 0, 0.7);
            const db = createEntity(SHAPE_TYPES.DATA, "数据库", -8, 2, 0, 0.7);
            const service = createEntity(SHAPE_TYPES.DATA, "本地服务", -6, 0, 0, 0.7);
            
            // 连接到本地数据
            createConnection(localData, files);
            createConnection(localData, db);
            createConnection(localData, service);
            
            // 创建远程服务
            const remote = createEntity(SHAPE_TYPES.REMOTE, "远程服务", 4, 2, 0, 1.3);
            
            // 创建子项
            const api = createEntity(SHAPE_TYPES.REMOTE, "API", 6, 4, 0, 0.7);
            const cloud = createEntity(SHAPE_TYPES.REMOTE, "云服务", 8, 2, 0, 0.7);
            const saas = createEntity(SHAPE_TYPES.REMOTE, "SaaS", 6, 0, 0, 0.7);
            
            // 连接到远程服务
            createConnection(remote, api);
            createConnection(remote, cloud);
            createConnection(remote, saas);
            
            // 创建 MCP Server
            const server = createEntity(SHAPE_TYPES.SERVER, "MCP Server", 0, -2, 0);
            
            // 连接 Server 到数据源
            createConnection(server, localData);
            createConnection(server, remote);
            
            // 添加安全标签
            addFloatingLabel("安全访问", -2, 0, 0);
            addFloatingLabel("通过API连接", 2, 0, 0);
        }
        
        // 完整工作流
        function showCompleteWorkflow() {
            // 标记当前是否处于动画状态
            let isAnimating = true;
            let animationPaused = false;
            let currentAnimationStep = 0;
            let animationTimeouts = [];
            
            // 添加工作流标签
            addFloatingLabel("完整 MCP 工作流", 0, 6, 0);
            
            // 创建所有实体，但初始时透明度设为0
            const llm = createEntity(SHAPE_TYPES.LLM, "LLM", 0, 4, 0, 1.4);
            const host = createEntity(SHAPE_TYPES.HOST, "Host 应用", -6, 2, 0);
            const client = createEntity(SHAPE_TYPES.CLIENT, "MCP Client", -3, 0, 0);
            const server = createEntity(SHAPE_TYPES.SERVER, "MCP Server", 0, -2, 0);
            const data = createEntity(SHAPE_TYPES.DATA, "数据源", 3, -4, 0);
            
            // 使所有实体初始透明
            [llm, host, client, server, data].forEach(entity => {
                entity.material.transparent = true;
                entity.material.opacity = 0;
                // 隐藏标签
                if (entity.children.length > 0) {
                    entity.children[0].visible = false;
                }
            });
            
            // 存储局部连接线和标签，以便动画控制
            const localConnections = [];
            const flowTexts = [];
            const dataBalls = [];
            
            // 定义动画步骤
            const animationSteps = [
                // 步骤1: 显示Host应用
                () => {
                    fadeInObject(host, 500, () => {
                        if (!animationPaused) nextAnimationStep();
                    });
                },
                
                // 步骤2: 显示LLM
                () => {
                    fadeInObject(llm, 500, () => {
                        // 创建Host和LLM之间的连接
                        const hostToLlm = createConnection(host, llm);
                        localConnections.push(hostToLlm);
                        
                        // 添加"用户请求"标签
                        const userRequestLabel = addFloatingLabel("用户请求", -3, 3, 0);
                        flowTexts.push(userRequestLabel);
                        
                        if (!animationPaused) nextAnimationStep();
                    });
                },
                
                // 步骤3: 显示Client
                () => {
                    fadeInObject(client, 500, () => {
                        if (!animationPaused) nextAnimationStep();
                    });
                },
                
                // 步骤4: Host向Client请求数据
                () => {
                    const hostToClient = createAnimatedConnection(host, client, "请求数据");
                    localConnections.push(hostToClient.line);
                    flowTexts.push(hostToClient.label);
                    
                    // 添加数据流动画效果 (Host -> Client)
                    const dataBall1 = createDataBall(host.position, client.position, 0x3498db);
                    dataBalls.push(dataBall1);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤5: 显示Server
                () => {
                    fadeInObject(server, 500, () => {
                        if (!animationPaused) nextAnimationStep();
                    });
                },
                
                // 步骤6: Client向Server转发请求
                () => {
                    const clientToServer = createAnimatedConnection(client, server, "转发请求");
                    localConnections.push(clientToServer.line);
                    flowTexts.push(clientToServer.label);
                    
                    // 添加数据流动画效果 (Client -> Server)
                    const dataBall2 = createDataBall(client.position, server.position, 0xe74c3c);
                    dataBalls.push(dataBall2);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤7: 显示数据源
                () => {
                    fadeInObject(data, 500, () => {
                        if (!animationPaused) nextAnimationStep();
                    });
                },
                
                // 步骤8: Server访问数据源
                () => {
                    const serverToData = createAnimatedConnection(server, data, "访问数据");
                    localConnections.push(serverToData.line);
                    flowTexts.push(serverToData.label);
                    
                    // 添加数据流动画效果 (Server -> Data)
                    const dataBall3 = createDataBall(server.position, data.position, 0xf39c12);
                    dataBalls.push(dataBall3);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤9: 数据源返回数据
                () => {
                    const dataToServer = createAnimatedConnection(data, server, "返回数据");
                    localConnections.push(dataToServer.line);
                    flowTexts.push(dataToServer.label);
                    
                    // 添加数据流动画效果 (Data -> Server)
                    const dataBall4 = createDataBall(data.position, server.position, 0x2ecc71);
                    dataBalls.push(dataBall4);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤10: Server向LLM提供上下文
                () => {
                    const serverToLlm = createAnimatedConnection(server, llm, "提供上下文", true);
                    localConnections.push(serverToLlm.line);
                    flowTexts.push(serverToLlm.label);
                    
                    // 添加数据流动画效果 (Server -> LLM)
                    const dataBall5 = createDataBall(server.position, llm.position, 0xf39c12);
                    dataBalls.push(dataBall5);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤11: LLM生成回复发送给Host
                () => {
                    const llmToHost = createAnimatedConnection(llm, host, "生成回复");
                    localConnections.push(llmToHost.line);
                    flowTexts.push(llmToHost.label);
                    
                    // 添加数据流动画效果 (LLM -> Host)
                    const dataBall6 = createDataBall(llm.position, host.position, 0x1abc9c);
                    dataBalls.push(dataBall6);
                    
                    if (!animationPaused) {
                        const timeout = setTimeout(() => nextAnimationStep(), 2000);
                        animationTimeouts.push(timeout);
                    }
                },
                
                // 步骤12: 完成工作流
                () => {
                    addFloatingLabel("MCP完成数据传递", 0, -6, 0);
                    document.getElementById('next-btn').disabled = false;
                    isAnimating = false;
                    
                    // 将局部连接线添加到全局connections数组，确保清除
                    localConnections.forEach(conn => {
                        if (!connections.includes(conn)) {
                            connections.push(conn);
                        }
                    });
                    
                    // 启用重新播放按钮
                    addReplayButton();
                    
                    // 隐藏动画控制面板
                    document.getElementById('animation-controls').style.display = 'none';
                }
            ];
            
            // 前进到下一个动画步骤
            function nextAnimationStep() {
                if (currentAnimationStep < animationSteps.length) {
                    // 执行当前步骤
                    animationSteps[currentAnimationStep]();
                    // 更新步骤计数
                    currentAnimationStep++;
                    // 更新步骤显示
                    if (document.getElementById('step-counter')) {
                        document.getElementById('step-counter').textContent = 
                            `步骤 ${currentAnimationStep}/${animationSteps.length}`;
                    }
                }
            }
            
            // 添加动画控制面板
            createAnimationControls();
            
            // 创建动画控制面板
            function createAnimationControls() {
                // 如果已存在则移除
                const existingPanel = document.getElementById('animation-controls');
                if (existingPanel) {
                    existingPanel.parentNode.removeChild(existingPanel);
                }
                
                const controlPanel = document.createElement('div');
                controlPanel.id = 'animation-controls';
                controlPanel.style.position = 'absolute';
                controlPanel.style.bottom = '80px';
                controlPanel.style.right = '20px';
                controlPanel.style.background = 'rgba(0,0,0,0.7)';
                controlPanel.style.padding = '10px';
                controlPanel.style.borderRadius = '5px';
                controlPanel.style.color = 'white';
                controlPanel.style.zIndex = '100';
                
                // 步骤计数器
                const stepCounter = document.createElement('div');
                stepCounter.id = 'step-counter';
                stepCounter.textContent = `步骤 ${currentAnimationStep}/${animationSteps.length}`;
                stepCounter.style.marginBottom = '10px';
                stepCounter.style.textAlign = 'center';
                controlPanel.appendChild(stepCounter);
                
                // 播放/暂停按钮
                const playPauseBtn = document.createElement('button');
                playPauseBtn.className = 'step-btn';
                playPauseBtn.textContent = '暂停';
                playPauseBtn.style.marginRight = '5px';
                playPauseBtn.addEventListener('click', () => {
                    animationPaused = !animationPaused;
                    playPauseBtn.textContent = animationPaused ? '继续' : '暂停';
                    
                    if (!animationPaused && currentAnimationStep < animationSteps.length) {
                        // 如果取消暂停，继续下一步
                        nextAnimationStep();
                    }
                });
                controlPanel.appendChild(playPauseBtn);
                
                // 下一步按钮
                const nextStepBtn = document.createElement('button');
                nextStepBtn.className = 'step-btn';
                nextStepBtn.textContent = '下一步';
                nextStepBtn.addEventListener('click', () => {
                    // 清除所有定时器
                    animationTimeouts.forEach(timeout => clearTimeout(timeout));
                    animationTimeouts = [];
                    
                    // 如果正在播放，先暂停
                    if (!animationPaused) {
                        animationPaused = true;
                        playPauseBtn.textContent = '继续';
                    }
                    
                    // 执行下一步
                    if (currentAnimationStep < animationSteps.length) {
                        nextAnimationStep();
                    }
                });
                controlPanel.appendChild(nextStepBtn);
                
                document.body.appendChild(controlPanel);
            }
            
            // 添加重播按钮
            function addReplayButton() {
                const replayBtn = document.createElement('button');
                replayBtn.className = 'step-btn';
                replayBtn.id = 'replay-btn';
                replayBtn.textContent = '重播动画';
                replayBtn.addEventListener('click', () => {
                    if (!isAnimating) {
                        clearScene();
                        showCompleteWorkflow();
                    }
                });
                document.getElementById('controls').appendChild(replayBtn);
            }
            
            // 禁用下一步按钮，直到动画完成
            document.getElementById('next-btn').disabled = true;
            
            // 开始第一个动画步骤
            nextAnimationStep();
        }
        
        // 创建数据流动动画球体
        function createDataBall(startPos, endPos, color) {
            // 创建小球
            const ballGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            
            // 将球体添加到场景
            ball.position.copy(startPos);
            scene.add(ball);
            objects.push(ball);
            
            // 设置动画
            const startTime = Date.now();
            const duration = 2000; // 2秒
            
            function animateBall() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutQuad(progress);
                
                // 计算当前位置
                ball.position.lerpVectors(startPos, endPos, easeProgress);
                
                // 如果没有完成，继续动画
                if (progress < 1) {
                    requestAnimationFrame(animateBall);
                } else {
                    // 动画完成后淡出小球
                    fadeOutObject(ball, 500, () => {
                        scene.remove(ball);
                        const index = objects.indexOf(ball);
                        if (index > -1) {
                            objects.splice(index, 1);
                        }
                    });
                }
            }
            
            // 开始动画
            requestAnimationFrame(animateBall);
            
            return ball;
        }
        
        // 创建带动画效果的连接线和标签
        function createAnimatedConnection(obj1, obj2, text, dashed = false) {
            const points = [];
            points.push(obj1.position.clone());
            points.push(obj2.position.clone());
            
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            let lineMaterial;
            
            if (dashed) {
                lineMaterial = new THREE.LineDashedMaterial({
                    color: 0xffffff,
                    dashSize: 0.3,
                    gapSize: 0.1,
                    transparent: true,
                    opacity: 0
                });
            } else {
                lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
            }
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            if (dashed) {
                line.computeLineDistances();
            }
            
            scene.add(line);
            
            // 计算中点
            const midPoint = new THREE.Vector3().addVectors(
                obj1.position,
                obj2.position
            ).multiplyScalar(0.5);
            
            // 添加标签，但最初是隐藏的
            const label = createTextLabel(text, midPoint.x, midPoint.y, midPoint.z);
            if (label.element) {
                label.element.style.opacity = 0;
            }
            
            // 添加箭头
            const arrowLength = 0.4;
            const direction = new THREE.Vector3().subVectors(obj2.position, obj1.position).normalize();
            const angle = Math.atan2(direction.y, direction.x);
            
            // 箭头位置 - 距离终点前一点
            const arrowX = obj2.position.x - arrowLength * Math.cos(angle);
            const arrowY = obj2.position.y - arrowLength * Math.sin(angle);
            
            const arrowGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
            const arrowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(arrowX, arrowY, 0);
            arrow.rotation.z = angle - Math.PI / 2;
            scene.add(arrow);
            objects.push(arrow);
            
            // 创建淡入动画
            fadeInObject(line, 1000);
            fadeInObject(arrow, 1000);
            
            // 标签淡入
            if (label.element) {
                fadeInElement(label.element, 1000);
            }
            
            return { line, label, arrow };
        }
        
        // 淡入对象
        function fadeInObject(obj, duration, callback) {
            if (!obj.material) return;
            
            const startTime = Date.now();
            const startOpacity = obj.material.opacity;
            const targetOpacity = 1.0;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutQuad(progress);
                
                // 更新透明度
                obj.material.opacity = startOpacity + (targetOpacity - startOpacity) * easeProgress;
                
                // 如果有子对象(如标签)，也显示它们
                if (obj.children.length > 0) {
                    obj.children[0].visible = true;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        // 淡出对象
        function fadeOutObject(obj, duration, callback) {
            if (!obj.material) return;
            
            const startTime = Date.now();
            const startOpacity = obj.material.opacity;
            const targetOpacity = 0.0;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutQuad(progress);
                
                // 更新透明度
                obj.material.opacity = startOpacity + (targetOpacity - startOpacity) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        // 淡入DOM元素
        function fadeInElement(element, duration, callback) {
            const startTime = Date.now();
            const startOpacity = parseFloat(element.style.opacity) || 0;
            const targetOpacity = 1.0;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutQuad(progress);
                
                // 更新透明度
                element.style.opacity = startOpacity + (targetOpacity - startOpacity) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        // 二次方缓动函数
        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }
        
        // 创建浮动文本标签（不附加到对象）
        function createTextLabel(text, x, y, z) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.textContent = text;
            
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.set(x, y, z);
            scene.add(label);
            labels.push(label);
            return label;
        }
        
        // 添加文本标签
        function addTextLabel(parent, text, yOffset = 1.2) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.textContent = text;
            
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.set(0, yOffset, 0);
            parent.add(label);
            labels.push(label);
            return label;
        }
        
        // 添加浮动标签（不附加到任何对象）
        function addFloatingLabel(text, x, y, z) {
            return createTextLabel(text, x, y, z);
        }
        
        // 创建连接线
        function createConnection(obj1, obj2, color = 0xaaaaaa, dashed = false) {
            const points = [];
            points.push(obj1.position.clone());
            points.push(obj2.position.clone());
            
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            let lineMaterial;
            
            if (dashed) {
                lineMaterial = new THREE.LineDashedMaterial({
                    color: color,
                    dashSize: 0.3,
                    gapSize: 0.1,
                });
            } else {
                lineMaterial = new THREE.LineBasicMaterial({ color: color });
            }
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            if (dashed) {
                line.computeLineDistances();
            }
            
            scene.add(line);
            connections.push(line);
            return line;
        }
        
        // 清除场景
        function clearScene() {
            // 清除对象
            objects.forEach(obj => scene.remove(obj));
            objects.length = 0;
            
            // 清除连接线
            connections.forEach(line => scene.remove(line));
            connections.length = 0;
            
            // 清除标签 - 确保从场景中移除
            labels.forEach(label => {
                if(label.parent) {
                    label.parent.remove(label);
                } else {
                    scene.remove(label);
                }
            });
            labels.length = 0;
            
            // 移除重播按钮（如果存在）
            const replayBtn = document.getElementById('replay-btn');
            if (replayBtn) {
                replayBtn.parentNode.removeChild(replayBtn);
            }
            
            // 移除动画控制面板（如果存在）
            const animationControls = document.getElementById('animation-controls');
            if (animationControls) {
                animationControls.parentNode.removeChild(animationControls);
            }
        }
        
        // 更新步骤描述
        function updateDescription(stepIndex) {
            document.getElementById('step-description').textContent = stepDescriptions[stepIndex];
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        // 开始演示
        function startDemo() {
            currentStep = 0;
            steps[currentStep]();
            
            document.getElementById('start-btn').disabled = true;
            document.getElementById('prev-btn').disabled = true;
            document.getElementById('next-btn').disabled = false;
            
            // 添加相机旋转动画
            animateCameraRotation(25, 1000);
        }
        
        // 相机旋转动画
        function animateCameraRotation(angleInDegrees = 30, duration = 1500) {
            // 保存初始状态
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            
            // 计算旋转角度（弧度）
            const angleInRadians = angleInDegrees * (Math.PI / 180);
            
            // 计算目标位置
            const radius = startPosition.distanceTo(startTarget);
            const startAngle = Math.atan2(startPosition.x - startTarget.x, startPosition.z - startTarget.z);
            const endAngle = startAngle + angleInRadians;
            
            // 设置动画参数
            let startTime = null;
            
            function animateRotation(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutCubic(progress);
                
                // 计算当前角度
                const currentAngle = startAngle + (endAngle - startAngle) * easeProgress;
                
                // 更新相机位置
                const newX = startTarget.x + radius * Math.sin(currentAngle);
                const newZ = startTarget.z + radius * Math.cos(currentAngle);
                
                camera.position.set(newX, startPosition.y, newZ);
                
                // 确保相机始终看向目标点
                camera.lookAt(startTarget);
                controls.update();
                
                // 继续动画直到完成
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }
            
            // 启动动画
            requestAnimationFrame(animateRotation);
        }
        
        // 缓动函数
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // 上一步
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                steps[currentStep]();
                
                document.getElementById('next-btn').disabled = false;
                if (currentStep === 0) {
                    document.getElementById('prev-btn').disabled = true;
                }
            }
        }
        
        // 下一步
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                steps[currentStep]();
                
                document.getElementById('prev-btn').disabled = false;
                if (currentStep === steps.length - 1) {
                    document.getElementById('next-btn').disabled = true;
                }
            }
        }
        
        // 重置演示
        function resetDemo() {
            clearScene();
            currentStep = -1;
            
            // 重置相机到默认位置
            camera.position.set(0, 0, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            
            document.getElementById('start-btn').disabled = false;
            document.getElementById('prev-btn').disabled = true;
            document.getElementById('next-btn').disabled = true;
            document.getElementById('step-description').textContent = 
                '欢迎来到 MCP 模型可视化！点击"开始"按钮开始演示。';
        }
        
        // 页面加载完成后初始化
        window.onload = init;
    </script>
</body>
</html> 